
# Лекция: Система контроля версий Git

## 1. Введение в контроль версий и отличие Git от других систем

**Системы контроля версий (Version Control Systems, VCS)** – это инструменты, которые позволяют отслеживать изменения в файлах и управлять историей этих изменений. Представьте, что вы работаете над проектом (программным кодом, документом и т.д.) и вам нужно сохранять разные версии работы, откатываться к предыдущим вариантам или совместно работать над файлами в команде. Без системы контроля версий разработчики часто создавали множество копий файлов с суффиксами вроде `_v1`, `_final`, `_final_real` и т.д., что неудобно и ненадежно. VCS автоматизирует и упорядочивает этот процесс.

**Основные преимущества контроля версий:**

- **Хранение истории изменений:** Все предыдущие версии файлов сохраняются, можно узнать кто и когда внес изменение, вернуть файл к прежнему состоянию.
- **Совместная работа:** Несколько разработчиков могут параллельно работать над проектом, а система помогает объединять их изменения.
- **Отслеживание ошибок:** Если новое изменение привело к ошибке, можно сравнить с предыдущей версией и найти причину или отменить проблемный код.
- **Безопасность данных:** Репозиторий с историей можно хранить на удаленном сервере – это резервная копия проекта. Даже если компьютер разработчика выйдет из строя, код не потеряется.

Существуют разные системы контроля версий. Ранее были популярны централизованные системы, такие как **Subversion (SVN)**, **CVS**, **Perforce**. В централизованной системе вся история хранится на одном центральном сервере, а разработчики получают копию актуальной версии файлов (без полной истории). При такой модели для большинства операций (например, чтобы получить историю или сделать коммит) нужен доступ к серверу. Кроме того, слияние изменений (merge) в некоторых старых системах было затруднено, поэтому разработчики часто избегали частого ветвления.

**Git** отличается тем, что это **распределенная** система контроля версий. Это означает, что при клонировании репозитория Git вы получаете **полную** копию всей истории изменений проекта на свой компьютер (локальный репозиторий). Нет единой точки отказа: каждый разработчик имеет полный репозиторий и может совершать почти все операции локально, без подключения к сети. Основные отличия Git от классических систем контроля версий:

- **Распределенность:** Каждый локальный репозиторий содержит всю историю. Коммиты создаются локально и потом при необходимости отправляются на сервер. Это повышает скорость работы (большинство команд выполняются мгновенно, не требуя сети) и надежность (при сбое сервера ничего не потеряется, т.к. у каждого разработчика есть копия истории).
- **Быстрое ветвление и слияние:** Git спроектирован с упором на частое ветвление (branching) и слияние (merging). Ветки в Git легковесны, их легко создать и объединить. В отличие от SVN, где ветка фактически копирует файлы на сервере, ветка в Git – это просто указатель на коммит. Это позволяет применять гибкие рабочие процессы (например, Feature Branch Workflow, Gitflow и др.), когда разработка новых фич ведется в отдельных ветках.
- **Snapshots vs Diffs (снимки vs различия):** Git хранит данные как **снимки состояния** (snapshots) файлов, а не как последовательность различий. Это значит, что каждый коммит в Git хранит полную версию всех файлов проекта (точнее, ссылки на них) на момент коммита. Однако для эффективности одинаковые файлы не дублируются – используются ссылки на уже сохраненные объекты. Такой подход ускоряет операции и упрощает модель данных. Многие другие VCS (например, SVN) хранят историю как набор изменений (diff) между версиями.
- **Локальные ветки и задачи:** Поскольку весь инструментарий истории доступен локально, разработчик может экспериментировать, делать отмены, просматривать историю без влияния на других. Только когда изменения готовы, их отправляют в общий (удаленный) репозиторий. Это облегчает параллельную разработку.
- **Популярность и экосистема:** Git стал чрезвычайно популярным, во многом благодаря платформам вроде GitHub, GitLab, Bitbucket, которые облегчают совместную работу (pull requests, обзоры кода, CI/CD интеграции). В результате Git во многом стал стандартом де-факто для контроля версий.

**Вывод:** Контроль версий необходим в современной разработке, а Git предоставляет быстрый, надежный и гибкий способ ведения истории проектов. Далее мы рассмотрим, как установить и использовать Git, а также основные концепции, которые нужно понимать каждому разработчику.

## 2. Установка и настройка Git (Windows, Linux, MacOS)

Перед началом работы необходимо установить Git на вашу систему. Рассмотрим процесс установки для разных операционных систем и начальную настройку.

**Windows:** На Windows наиболее простой способ – скачать установщик **Git for Windows** с официального сайта Git (https://git-scm.com/download/win). Запустите `.exe` файл и пройдите шаги мастера установки (обычно можно оставить параметры по умолчанию). В состав Git for Windows входит эмулятор терминала Git Bash, который позволяет выполнять команды Git в UNIX-подобной среде. После установки вы сможете запускать *Git Bash* или использовать Git команды из PowerShell/CMD. Проверьте успешность установки, выполнив команду в терминале: 

```bash
git --version
``` 

Она должна вывести версию Git. Обновления Git на Windows можно устанавливать повторно скачивая свежий установщик или через пакетный менеджер **Chocolatey** командой `choco install git` (если у вас установлен Chocolatey).

**Linux:** Многие дистрибутивы Linux включают Git по умолчанию. Чтобы проверить, установлена ли программа, выполните `git --version`. Если Git не найден, установите его через менеджер пакетов вашего дистрибутива. Например, для Debian/Ubuntu:

```bash
sudo apt update
sudo apt install git
```

Для CentOS/RHEL: `sudo yum install git`, для Fedora: `sudo dnf install git`. Также Git можно собрать из исходников, но в большинстве случаев достаточно пакетного менеджера. После установки команда `git --version` должна показать номер версии Git.

**MacOS:** На macOS Git может быть установлен вместе с Xcode Command Line Tools. Попробуйте выполнить в терминале команду `git --version`. Если Git не установлен, система предложит установить инструменты разработчика Xcode – согласитесь и следуйте инструкциям (скачивание и установка произойдут автоматически). Альтернативный способ – установить пакет **Homebrew** (менеджер пакетов для macOS) и выполнить `brew install git`. Кроме того, на сайте git-scm.com доступен графический установщик для macOS. После установки проверьте версию аналогично (`git --version`).

**Первоначальная настройка Git:** После установки Git необходимо указать свои пользовательские данные, которые будут вписываться в каждый коммит – как минимум имя и email. Для этого используются команды настройки:

```bash
git config --global user.name "Ваше Имя"
git config --global user.email "you@example.com"
```

Эти команды сохранят ваше имя и email в глобальном конфигурационном файле Git (обычно `~/.gitconfig` в вашем домашнем каталоге). Флаг `--global` означает, что настройка применяется для **всех** репозиториев данного пользователя. Вы можете настроить и другие параметры, например предпочитаемый текстовый редактор для сообщений коммитов:

```bash
git config --global core.editor "nano"
```

*(замените "nano" на ваш редактор, например "code --wait" для VS Code или "notepad" для Windows блокнота).* 

Еще одна распространенная настройка – авто-перевод окончаний строк (различается в Windows и Unix). На Windows часто включают опцию `git config --global core.autocrlf true` (чтобы Git автоматически конвертировал окончания строк CRLF↔LF при переносе между Windows и репозиторием). На Linux/Mac обычно `core.autocrlf` выставляют в `input` или `false`. Детали этой настройки выходят за рамки введения, но упоминание важно, если вы работаете в межплатформенной команде.

После установки и настройки можно снова проверить конфигурацию командами:

```bash
git config --list
```

Эта команда покажет все настройки Git (глобальные и для текущего репозитория, если в нем находитесь). Убедитесь, что там присутствуют ваше имя и email. Теперь окружение готово – можно создавать репозиторий и выполнять команды Git.

## 3. Внутреннее устройство Git: как он хранит данные, работа с каталогом `.git`

Чтобы эффективно пользоваться Git, полезно понимать в общих чертах, как он устроен внутри. Основная особенность Git – хранение истории в виде **объектов** мгновенных снимков (snapshot) файлов, а не как последовательность патчей.

Когда вы инициализируете репозиторий (командой `git init`, о которой позже), Git создает скрытый каталог `.git`. Этот каталог содержит **всю историю** вашего проекта и служебные файлы Git. Если его удалить или переместить – репозиторий “сломается” (папка `.git` делает папку репозиторием). Рассмотрим упрощенно содержимое `.git`:

- **Объекты (objects):** Git хранит каждый закоммиченный файл в сжатом виде (объекты типа *blob*), а также дерево (объект *tree*), отражающее структуру каталогов и имена файлов, и объект *commit*, содержащий метаданные коммита. Каждый объект имеет уникальный идентификатор – SHA-1 хеш (40-символьная строка, например `e4ca758...`), вычисленный от содержимого. Эти хеши используются Git для адресации – например, коммит хранится по своему SHA-1. В `.git/objects` вы найдете множество папок с именами из двух символов и файлами с именами из оставшихся 38 символов – это и есть хранилище объектов.
- **Ссылки (refs) и ветки:** Git хранит указатели на определенные коммиты. Ветки – это именованные ссылки на коммиты в `refs/heads/`. Например, ветка `master` (или `main`) хранится в файле `.git/refs/heads/master` и содержит хеш коммита, на который указывает ветка. Когда вы создаете новый коммит на ветке, содержимое этого файла обновляется на новый хеш. Также в папке `refs/` есть каталоги `remotes/` (для ссылок на удаленные ветки) и `tags/` (для тегов).
- **HEAD:** Это особый указатель, хранящийся в файле `.git/HEAD`. Он указывает на текущую ветку (или непосредственно на коммит, если вы “отвязались” от ветки – *detached HEAD*). По сути, HEAD содержит либо ссылку типа `ref: refs/heads/master` (т.е. "сейчас активна ветка master"), либо конкретный хеш коммита (в режиме detached). HEAD важен для понимания, где вы находитесь: большинство команд (commit, merge и др.) работают относительно HEAD.
- **Индекс (index) / staging area:** Это область промежуточного хранения изменений перед коммитом. Технически, индекс – это файл `.git/index`, где Git отслеживает, какие изменения подготовлены (*staged*) для следующего коммита. Когда вы выполняете `git add`, добавляемые изменения записываются в индекс.
- **Конфигурация и прочее:** В `.git` также хранятся настройки репозитория (`.git/config`), журнал операций (`.git/logs/`), информация для слияния (`.git/MERGE_HEAD` и др., появляются во время conflicта), временные файлы и др. Например, при операции *rebase* Git может использовать папку `.git/rebase-apply` для промежуточных данных.

**Как Git хранит историю:** Каждый коммит в Git содержит ссылку на родительский коммит (или несколько, если это merge-коммит). Таким образом, коммиты образуют цепочку (на графе истории – направленный ациклический граф). Благодаря этому, имея хеш последнего коммита ветки, Git может пройти по родителям и восстановить всю историю. **Важно:** Git не хранит *изменения* между коммитами, он хранит **полные снимки**. Но за счет того, что неизмененные файлы между коммитами повторно не сохраняются (а ссылаются на один и тот же blob-объект), репозиторий эффективно хранит только уникальное содержимое. Например, если вы изменили один файл в проекте из 1000 файлов, новый коммит будет содержать один новый blob (для измененного файла), новый tree (для папки, где файл лежит, и верхние деревья до корня) и новый commit-объект, ссылающийся на старые объекты для всех остальных файлов. Это очень эффективное дельта-сжатие, но логика работы проще: все как снимки.

Таким образом, Git локально хранит полную базу данных проекта. Это позволяет выполнять команды **быстро**: просмотр истории, переключение на любую версию – это просто чтение локальных файлов, без запросов к серверу.

**Отличие от других систем:** Например, SVN хранит на сервере последовательность изменений, и чтобы собрать состояние проекта на определенную дату, нужно применить патчи. Git же просто берет нужный снимок. Это упрощает слияние и разветвление истории. Каждый разработчик работает со своей полной базой (`.git`), а обмен изменениями между командами происходит путем передачи *коммитов* (их объектов) между репозиториями.

Практически, зная это устройство, вы понимаете, что **резервное копирование** репозитория сводится к копированию папки `.git`. Вы также можете исследовать `.git` (например, посмотреть содержимое HEAD, config, и т.д.) чтобы понять состояние репозитория. Но обычно напрямую там править ничего не нужно – для этого есть команды Git.

Резюмируя, Git – это **файловая система объектов**, снабженная инструментами для записи истории. Теперь перейдем к практическим основам работы с Git.

## 4. Основные концепции: коммиты, ветки, HEAD, удалённые репозитории

Перед практикой важно усвоить несколько ключевых понятий Git:

- **Репозиторий (Repository):** Хранилище проекта, содержащее всю историю изменений. Локальный репозиторий – это каталог с подпапкой `.git`. Удаленный репозиторий – копия проекта, хранящаяся на сервере или в облаке (например, репозиторий на GitHub). Обычно локальный и удаленный репозитории синхронизируются через `push`/`pull`.
- **Коммит (Commit):** Зафиксированные изменения (снимок состояния проекта). Коммит в Git содержит: автор и дата, комментарий (сообщение коммита), ссылки на родительские коммиты и ссылку на корневое дерево снимка проекта. У каждого коммита есть уникальный идентификатор (SHA-1 хеш, обычно первые 7-10 символов достаточно для уникальности). Коммиты образуют историю проекта. Можно представить коммит как точку в истории с описанием изменений. Создается командой `git commit`.
- **Ветка (Branch):** Именованный указатель на коммит. Обычно ветка указывает на "последний" коммит в цепочке работы. Например, по умолчанию при создании репозитория появляется ветка `master` (с недавних пор во многих сервисах по умолчанию называется `main`). Когда вы делаете новый коммит на ветке, указатель ветки перемещается на этот новый коммит. Ветки позволяют изолировать параллельную работу: например, вы можете создать ветку `feature-x` для разработки новой функциональности, не затрагивая основную ветку, пока работа не будет готова.
- **HEAD:** Специальный указатель на текущий *активный* коммит/ветку. Проще говоря, HEAD – это "то, над чем вы сейчас работаете". Обычно HEAD указывает на имя ветки. Например, HEAD -> master означает, что сейчас вы находитесь на ветке master, и HEAD неявно указывает на последний коммит этой ветки. Если HEAD "отвязан" (detached HEAD), это значит вы переключились на конкретный коммит или тег, не находясь ни на одной ветке – в таком состоянии новые коммиты создадут новую историю без имени (часто такое делают временно, и потом переходят обратно на ветку).
- **Рабочая директория (Working Directory):** текущий каталог проекта (вне `.git`), где находятся ваши файлы для редактирования. Вы вносите изменения в файлы в рабочей директории.
- **Index/Staging Area (Индекс, область индексирования):** промежуточная область, где вы готовите (*стейджите*) изменения для коммита. Выше уже упоминалось, что Git индексирует изменения, когда вы вызываете `git add`. Индекс позволяет точно контролировать, что пойдет в следующий коммит (можно добавить не все изменения, а выборочно). Коммит фиксирует состояние **индекса** на момент коммита.
- **Удалённый репозиторий (Remote Repository):** обычно обозначает серверный репозиторий, с которым связан ваш локальный. Например, клонируя проект с GitHub, вы получаете удаленный с именем `origin`. Удаленный репо содержит, как правило, ту же историю (или суперсет истории) что и локальный, и служит для обмена изменениями между разработчиками. С удаленным репозиторием вы взаимодействуете командами `git fetch`, `git pull`, `git push` (о них далее). 

На диаграмме ниже показано, как коммиты образуют историю, а ветка (master) указывает на последний коммит. HEAD указывает на активную ветку:

 ([Git - Branches in a Nutshell](https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell)) *Пример: коммиты (белые блоки) A -> B -> C, образующие историю; ветка `master` (оранжевый блок) указывает на последний коммит C; HEAD (желтый блок) указывает на ветку `master`. Также показан тег `v1.0` на коммите B. “Snapshot” здесь означает снимок состояния проекта при каждом коммите.* 

Каждый коммит обладает ссылкой на предыдущий, поэтому ветка – не более чем название для текущей точки истории. Вы можете создавать множество веток и переключаться между ними, что никак не потеряет историю: старые ветки можно восстановить по коммитам.

**Итог:** Коммит – это единица работы (фиксированная версия), ветки – удобные маркеры для последовательностей коммитов, HEAD – ваш текущий контекст, а удаленные репозитории позволяют обмениваться коммитами между командами. Понимая эти концепции, перейдем к практическому использованию Git.

## 5. Создание репозитория, базовые команды (`init`, `add`, `commit`, `log`)

Теперь начнем практическую часть. Предположим, вы создали новый проект (или хотите взять под контроль версий существующую папку с кодом). Нужно превратить папку в Git-репозиторий.

**Создание (инициализация) репозитория** – команда `git init`. Внутри выбранной папки (проекта) выполните:

```bash
$ git init
```

Вывод команды (если все прошло успешно) будет примерно таким:

```
Initialized empty Git repository in /path/to/your/project/.git/
```

Git создал скрытую папку `.git` и тем самым инициализировал пустой репозиторий. Пока что история пуста (нет ни одного коммита), и никакие файлы не находятся под версионным контролем.

**Добавление файлов под контроль версий** – команда `git add`. После инициализации статус будет “чистым”. Добавим первый файл. Создадим, например, файл `README.md` с некоторым содержимым. Вызовем `git status` (подробнее о `status` в следующем разделе) и увидим, что файл отображается в списке *Untracked files* (неотслеживаемые файлы). Чтобы начать отслеживать файл (то есть добавить его в индекс), выполняем:

```bash
$ git add README.md
```

Теперь файл помещен в staging area (индекс). При следующем коммите этот файл войдет в историю. Можно добавлять несколько файлов или целые каталоги. Например, `git add .` добавит *все* изменения (новые, измененные файлы) в текущем каталоге и ниже. Будьте осторожны с этой командой в больших проектах – иногда лучше добавлять выборочно, чтобы не включить лишнего.

**Фиксация изменений** – команда `git commit`. После того как нужные изменения добавлены в индекс, создадим первый коммит:

```bash
$ git commit -m "Initial commit"
```

Флаг `-m "сообщение"` позволяет указать комментарий коммита прямо в командной строке. Сообщение коммита **обязательно**, оно должно кратко описывать сделанные изменения. В нашем случае “Initial commit” – стандартное сообщение для первого коммита. После выполнения появится вывод, например:

```
[master (root-commit) bd4c816] Initial commit
 1 file changed, 1 insertion(+)
 create mode 100644 README.md
```

Разберем его: `[master bd4c816]` – означает, что коммит сделан в ветку `master`, его хеш (первые 7 символов) bd4c816. Метка `(root-commit)` указывает, что это первый коммит в истории (нет родителя). Далее Git сообщает статистику: сколько файлов изменено, сколько строк добавлено/удалено, а также что создан новый файл README.md с правами `100644` (обычный файл). Теперь у нас есть первый коммит в истории репозитория.

**Просмотр истории коммитов** – команда `git log`. После нескольких коммитов вам захочется увидеть историю изменений. Команда `log` выводит список коммитов, начиная с последнего:

```bash
$ git log
```

По умолчанию она покажет каждый коммит с деталями:

- SHA-1 хеш коммита (длинная строка из цифр и букв),
- автора и дату,
- сообщение коммита.

Например, если мы сделаем еще несколько коммитов и вызовем `git log`, может получиться что-то вроде:

```
commit 239eae6e1f09c3b8b8f93e4d3e0f8d3025d9c21e (HEAD -> master)
Author: Your Name <you@example.com>
Date:   Mon Mar 10 17:00:12 2025 +0300

    Add feature X implementation

commit bd4c8167c9ef26d1d2baf34c6fbbf899c0dcbc3a
Author: Your Name <you@example.com>
Date:   Mon Mar 10 16:45:05 2025 +0300

    Initial commit
```

Здесь видно два коммита. Верхний – последний (HEAD -> master означает, что HEAD указывает на ветку master, а она – на этот коммит). У него есть сообщение "Add feature X implementation". Ниже – наш первый коммит. История читается сверху вниз (новые – наверху). У логов есть множество опций: `git log --oneline` выводит коммиты в одну строку (удобно для краткого обзора), `git log --graph --all` рисует ASCII-диаграмму ветвления. Но в начале достаточно знать базовую форму.

**Итого базовый цикл работы:** после `git init` –> `git add` (добавить изменения в индекс) –> `git commit` (зафиксировать в истории). Повторять `add` + `commit` при каждом логическом наборе изменений. В репозитории накапливается история, которую можно просматривать через `git log`. Далее мы подробнее рассмотрим, как отслеживать состояние файлов и управлять изменениями до коммита, а также как работать с ветками.

## 6. Работа со *staging area*, управление состоянием файлов (`status`, `reset`)

В Git файлы могут находиться в разных **состояниях**: *неотслеживаемые* (untracked), *отслеживаемые неизмененные* (unmodified), *измененные* (modified), *проиндексированные для коммита* (staged). Понимание этих состояний и умение проверять статус – ключ к эффективной работе.

**Команда состояния `git status`:** показывает, что Git видит в текущем репозитории, и подсказки для дальнейших действий. Обычно `git status` выводится в три блока:
- **Changes to be committed:** (Изменения, подготовленные к коммиту) – список файлов, добавленных в индекс (staged). Эти изменения попадут в следующий коммит.
- **Changes not staged for commit:** (Изменения, не подготовленные к коммиту) – файлы, отслеживаемые Git, которые были изменены в рабочей директории, но еще не добавлены в индекс. Они не будут зафиксированы, пока вы их не `git add`.
- **Untracked files:** (Неотслеживаемые файлы) – файлы, существующие в рабочем каталоге, но не отслеживаемые Git (никогда не коммитились и не были добавлены). Git игнорирует их содержимое до тех пор, пока вы не выполните `git add` для них.

Пример вывода `git status` в разных ситуациях:

- Сразу после клонирования или коммита без новых изменений:

```bash
$ git status
On branch master
nothing to commit, working tree clean
```

Сообщение *working tree clean* означает, что **рабочая директория чиста** – нет ни несохраненных изменений, ни неотслеживаемых файлов. Репозиторий находится на ветке `master` и никаких новых коммитов не требуется.

- Добавили новый файл, но не проиндексировали его:

```bash
$ echo "My Project" > README.md   # создаем новый файл
$ git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)

        README.md

nothing added to commit but untracked files present (use "git add" to track)
```

Мы видим раздел *Untracked files* с файлом README.md. Git подсказывает, что можно использовать `git add` для начала отслеживания. Внизу фраза *nothing added to commit but untracked files present* уточняет, что в индекс пока ничего не добавлено.

- Выполним `git add README.md` и снова проверим статус:

```bash
$ git add README.md
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
  
        new file:   README.md
```

Теперь файл переместился в раздел *Changes to be committed* и помечен как `new file`. Это означает, что этот новый файл проиндексирован и готов для коммита. Обратите внимание, Git подсказывает команду для отмены *стейджинга*: `git restore --staged <file>` (в более старых версиях Git вместо `restore` подсказка будет `git reset HEAD <file>`). Об этой команде ниже.

- Если мы изменим уже отслеживаемый файл, но не добавим изменение в индекс:

```bash
$ echo "One more line" >> README.md   # редактируем файл, например добавляем строку
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)

        modified:   README.md
```

Теперь README.md появляется в разделе *Changes not staged for commit* как *modified*. То есть Git отслеживает этот файл (он уже был в репозитории), и обнаружил изменения, но они пока не включены в индекс. Подсказки подсказывают: `git add` чтобы включить изменения в коммит, или `git restore <file>` чтобы отменить изменения в рабочей директории (вернуть файл к состоянию последнего коммита).

**Отмена изменений и управление индексом:** Часто нужно отменить ошибочно добавленные изменения или снять файл из индекса. Рассмотрим несколько случаев:

- **Убрать файл из индекса (unstage):** Если вы добавили файл в индекс, но передумали включать его в коммит, используйте команду:

```bash
git restore --staged <file>
```

В старой нотации то же самое: `git reset HEAD <file>`. Эта команда оставит файл в рабочей директории, но удалит из staging area, т.е. Git больше не будет включать его изменения в следующий коммит (пока вы снова не сделаете `git add`). В нашем примере, если выполнить `git restore --staged README.md`, файл вернется в состояние *modified/untracked* (в зависимости от того, был ли он ранее в репозитории).

- **Отменить изменения в файле (discard changes):** Если файл был изменен в рабочей директории и вы хотите вернуть последнюю зафиксированную версию (отменить все правки), можно использовать:

```bash
git restore <file>
```

Раньше для этого применяли `git checkout -- <file>`. *Осторожно:* эта команда **уничтожит несохраненные изменения** в `<file>`, заменив его содержимым из HEAD (последнего коммита). Ее нельзя отменить через Git (разве что снова внести изменения вручную), поэтому убедитесь, что действительно хотите отбросить правки. Применяется, например, если вы случайно внесли изменения и решили их не сохранять.

- **Удаление файла из под контроля версий:** Если вы хотите удалить файл из проекта и из репозитория, используйте `git rm <file>` (он удалит файл из рабочей директории и добавит факт удаления в индекс, чтобы на коммите файл исчез из проекта). Если же нужно оставить файл в рабочей директории, но убрать из репозитория (например, файл больше не нужен под версионным контролем), то: `git rm --cached <file>` – Git перестанет отслеживать файл, но сам файл останется на диске. Обычно потом такой файл добавляют в `.gitignore`, чтобы Git не предлагал добавить его снова.

- **Reset vs restore:** Новички часто путаются между `git reset` и `git restore` (и старым использованием `git checkout`). Проще помнить так: 
  - `git restore` применяется к файлам, чтобы вернуть содержимое (или снять со staging).
  - `git reset` часто применяется к коммитам/веткам, чтобы передвинуть указатель HEAD (об этом больше в разделе 9). Также `git reset HEAD <file>` – старый способ unstaging. 
Git в новых версиях разделил функции на более узкие команды: `restore` (работа с файлами), `switch` (переключение веток) вместо универсального `checkout`, но `checkout` тоже ещё широко используется.

**Практический пример управления состояниями:** Представим, вы отредактировали несколько файлов, затем решили, что один из них еще не готов для коммита:
1. Вы выполняете `git add .` – все изменения добавились в индекс.
2. Командой `git status` вы видите 5 файлов *Changes to be committed*. Но один файл `app/config.py` не должен попасть в коммит.
3. Вы выполняете `git restore --staged app/config.py`. Теперь `app/config.py` убран из индекса (переместился обратно в *modified*). Остальные 4 файла останутся staged.
4. Вы можете дополнительно решить, что изменения в `app/config.py` вообще стоит отменить: `git restore app/config.py` – и файл вернется к версии HEAD, а ваши изменения в нем исчезнут.
5. Теперь делаете `git commit -m "Update four files"`. В коммит попадут только 4 файла, как вы и хотели. Файл `app/config.py` останется измененным на диске (если вы не restore, а просто убрали из staging) – можно доработать и закоммитить его позже.

Таким образом, `git status` + `git add`/`restore` позволяют вам контролировать, что именно фиксируется.

**Вывод `git diff`:** Ещё полезно видеть сами изменения. Команда `git diff` показывает строчки, которые были добавлены/удалены/изменены. По умолчанию `git diff` сравнивает *несохраненные изменения* в рабочей директории с последним коммитом. Если вы уже добавили изменения в индекс, то `git diff` будет чистым, но `git diff --staged` покажет разницу между индексом и последним коммитом (то, что пойдет в коммит). Используйте эти команды, чтобы убедиться, какие изменения вы сделали, перед тем как зафиксировать их. Фрагмент вывода `git diff` может выглядеть так:

```diff
--- a/README.md
+++ b/README.md
@@
-Line2
+Line2 modified in feature
```

Знак `-` показывает удаленную строку, `+` – добавленную. В данном примере строка "Line2" заменена на "Line2 modified in feature".

Мы еще вернемся к `git diff` при обсуждении истории, но на этапе редактирования он помогает просматривать текущие изменения.

Итак, **staging area (индекс)** – ключевая "фишка" Git, позволяющая подготовить коммит. Команды `status`, `add`, `restore`/`reset` помогают управлять состоянием файлов: видеть статус, добавлять в коммит, убирать или отменять изменения. После того как индекс содержит нужные изменения, выполняется `git commit`, и эти изменения навсегда входят в историю (или по крайней мере, до тех пор, пока их явно не удалить инструментами переписывания истории).

## 7. Работа с ветками: создание, переключение, слияние (`checkout`, `merge`, `rebase`)

Одна из самых мощных возможностей Git – легкое ветвление и слияние. Ветки позволяют одновременно вести несколько линий разработки. Рассмотрим основные операции: как создавать ветки, переключаться между ними, сливать изменения, и что такое rebase.

### Создание новой ветки

Допустим, у вас есть репозиторий с одной веткой `master`. Вы хотите начать работу над новой функцией, не мешая основному коду. Создадим ветку **feature-X**. Сначала два способа:

- **Способ 1:** создать ветку, затем переключиться на нее:

  ```bash
  git branch feature-X      # создать новую ветку feature-X (на текущем коммите)
  git checkout feature-X    # переключиться на ветку feature-X
  ```
  После первой команды ветка появится, но HEAD всё ещё на старой ветке, поэтому нужно `checkout`. Эти две команды можно объединить в одну.

- **Способ 2 (коротко):** создание и сразу переход:

  ```bash
  git checkout -b feature-X
  ```
  Флаг `-b` создаст новую ветку с указанным именем и сразу сделает `checkout` на нее. В новых версиях Git можно использовать эквивалент: `git switch -c feature-X` (команда `switch` предназначена только для переключения/создания веток).

После выполнения у вас будет новая ветка feature-X, которая "отпочковалась" от того же коммита, где вы стояли (если вы были на master, то она копирует мастер на момент создания). Команда `git branch` без аргументов показывает список веток и указывает `*` текущую. Например:

```
$ git branch
* feature-X
  master
```

Звездочка показывает, что сейчас активна `feature-X`. Также `git status` сообщит “On branch feature-X”.

Теперь вы можете делать коммиты в ветке feature-X. Они будут независимы от ветки master (которая останется на прежнем коммите, пока вы в нее не вернетесь).

### Переключение между ветками

Для переключения используется `git checkout <branch>` (или `git switch <branch>`). Важно: Git требует, чтобы **рабочая директория не содержала несохраненных изменений**, которые невозможно автоматически перенести. Обычно перед сменой ветки вы должны или закоммитить изменения, или спрятать их (есть инструмент `git stash` для временного сохранения изменений – вне рамок текущей лекции). Если вы попробуете переключиться, имея некоммиченные изменения, которые конфликтуют с целевой веткой, Git откажется сделать checkout.

Предположим, вы находитесь на feature-X и хотите вернуться на `master`:

```bash
git checkout master
```

HEAD теперь снова указывает на master, файлы в рабочем каталоге обновятся до состояния последнего коммита на master. Коммиты, сделанные вами в feature-X, как бы "исчезнут" из рабочей директории (они никуда не делись – просто остались в той ветке). Если теперь открыть файл, измененный в feature-X, вы увидите старую версию (как было на master). Вернувшись на feature-X (`git checkout feature-X`), получите обратно новую версию.

Таким образом, ветки позволяют мгновенно переключать контекст разработки.

### Слияние веток (merge)

Когда работа в отдельной ветке завершена, обычно изменения сливают обратно в основную ветку (например, в master). Команда слияния:

```bash
git checkout master        # переходим в ветку, куда хотим влить изменения
git merge feature-X        # сливаем ветку feature-X в текущую (master)
```

При выполнении `git merge <source>` Git пытается интегрировать коммиты из ветки `<source>` в текущую ветку. Существует два основных случая:

- **Fast-forward merge (линейное “перемотка”):** если ветка `master` не имела новых коммитов с момента ответвления feature-X, то master просто сдвинет указатель на последний коммит из feature-X. Произойдет “быстрое перематывание”, без создания нового коммита слияния. История станет линейной. Например, master указывал на C, feature-X на E (потомок C). После `merge feature-X` master тоже будет указывать на E. Вывод Git при fast-forward:

  ```
  Updating 239eae6..d57ccb4
  Fast-forward
   file1.txt | 2 +-
   file2.txt | 1 +
   2 files changed, 3 insertions(+), 1 deletion(-)
  ```
  Он перечисляет изменения, которые появились из ветки (в данном примере изменены file1.txt и file2.txt).

- **Обычное слияние с коммитом (трехстороннее слияние):** если в обеих ветках есть уникальные коммиты (они развивались параллельно), Git создаст новый коммит слияния (merge commit). Этот коммит будет иметь два родителя: один – последний коммит в master до слияния, другой – последний коммит в feature-X. История станет ветвистой (будет виден расходящийся и сходящийся граф). Пример вывода:

  ```
  Merge made by the 'recursive' strategy.
   file3.txt | 5 +++++
   1 file changed, 5 insertions(+)
  ```
  Git сообщает, что выполнено слияние (по умолчанию стратегией recursive). В логах появится новый коммит с сообщением по умолчанию "Merge branch 'feature-X' into master" (можно задать свое сообщение, используя `git merge -m "..."`).

После слияния ветка `feature-X` останется доступна, но обычно, если она больше не нужна, ее удаляют командой `git branch -d feature-X` (флаг -d означает удалить локальную ветку; Git не позволит удалить ветку, если в ней есть уникальные ненамердженные коммиты, чтобы не потерять историю).

**Пример:** Предположим, master имел коммиты A -> B. Вы создали feature-X от B и сделали коммиты C -> D в этой ветке. Пока вы работали, в master кто-то добавил коммит E (после B). Теперь ветка master: A -> B -> E, ветка feature-X: A -> B -> C -> D. Чтобы слить feature-X в master, вы переключаетесь на master, выполняете `git merge feature-X`. Поскольку история разошлась, Git создаст коммит слияния F, у которого два родителя: E и D. История станет: A -> B -> E -> F (merge) <- D <- C (вторая линия). После этого master указывает на F. Все изменения из C и D теперь есть в master. Команда `git log --graph --oneline` красиво покажет слияние:

```
*   f30abf0 (HEAD -> master) Merge branch 'feature-X'
|\  
| * 874ab2c (feature-X) Commit D
| * 3b42c8d Commit C
* | 6ae8231 Commit E
|/  
* d1c6aee Commit B
* 98ca9fe Commit A
```

*(Не обязательно запоминать синтаксис графа, важно понять принцип.)*

### Разрешение конфликтов при слиянии

Иногда Git не может автоматически выполнить слияние – возникает **конфликт**. Это происходит, если изменения в двух ветках затрагивают одну и ту же часть одного и того же файла, и Git не может однозначно решить, какая версия правильнее. Конфликты рассмотрим подробно в следующем разделе (8), а здесь отметим: при конфликте `git merge` остановится, сообщив какие файлы конфликтуют, и потребует ручного вмешательства. После ручного разрешения изменений нужно завершить слияние (`git add` для помеченных файлов и `git commit` для фиксации).

### Перебазирование (rebase)

Помимо `merge`, Git предлагает другой способ интеграции веток – **rebase (перебазирование)**. Rebase – это операция, которая “переписывает” историю коммитов, как будто они сделаны позже, на новой базе. Проще понять на примере:

Опять же, две ветки разошлись: master: A -> B -> E, feature-X: B -> C -> D (C и D основаны на B). Вместо создания merge-коммита, вы можете *перебазировать* ветку feature-X на актуальную master. Для этого, находясь на ветке feature-X, выполните:

```bash
git rebase master
```

Git возьмет коммиты feature-X (C и D), временно сохранит их патчи, переместит ветку feature-X на конец master (на E) и применит коммиты C и D поверх E. Получится, что история feature-X станет выглядеть как A -> B -> E -> C' -> D' (штрих – т.к. хеши коммитов изменятся, это новые объекты). Затем вы можете переключиться на master и сделать fast-forward merge (потому что теперь мастер отстает, но без разветвления). В итоге история будет линейной: A -> B -> E -> C' -> D'. Это равносильно тому, что коммиты C и D произошли после E, а не параллельно.

**Когда использовать rebase vs merge:** Rebase позволяет сохранить историю без лишних коммитов слияния, линейно. Это эстетически приятнее и иногда облегчает понимание истории. Однако rebase *переписывает историю* ветки – старые коммиты C, D заменяются новыми. Поэтому **нельзя делать rebase для уже опубликованных коммитов**, которыми могли воспользоваться другие. Обычно rebase применяют для локальных веток перед отправкой, либо в рамках одного репозитория (в pull requests тоже иногда предпочитают "Rebase and merge" стратегию). Merge же сохраняет историю "как есть" и добавляет коммит слияния – в общей ветке будут видны точки слияния.

Для начинающих проще начать с merge, но знать о rebase полезно. Например, часто обновляют свою фичу: `git pull --rebase origin master` – эта команда обновит ваш локальный master и перебазирует текущую ветку поверх него, вместо создания лишнего коммита. Вы получите свои изменения как бы поверх последних обновлений.

**Пример команды rebase:** находясь на feature-X, `git rebase master`. Если возникнут конфликты, rebase приостановится, их нужно решить так же, как при merge (появятся метки конфликтов в файлах). После разрешения конфликтов выполняется `git rebase --continue` для продолжения. В конце, feature-X переместится. 

**Итого:** `git branch`/`checkout`/`switch` для создания и перехода на ветки, `git merge` для слияния (может быть fast-forward или с коммитом), `git rebase` для "подтягивания" изменений без явного merge-коммита. Практика работы с ветками требует внимания к конфликтам, о которых речь пойдет далее.

## 8. Разрешение конфликтов при слиянии

**Конфликт слияния (merge conflict)** – ситуация, когда Git не может автоматически объединить изменения из разных веток. Обычно это происходит, если один и тот же фрагмент файла был изменен в обеих ветках. Git останавливает слияние и дает вам возможность вручную решить, что должно быть в финальной версии.

Рассмотрим реальный пример. Пусть у нас есть файл `config.txt` в ветке master со строкой:

```
timeout = 30
```

Мы создаем ветку `featureA` и там изменяем эту строку на `timeout = 60` (увеличили время ожидания). Коммитим изменение в featureA. Независимо, в `master` кто-то в то же время изменил эту же строку на `timeout = 45` (другой подход). Теперь, если мы попытаемся слить ветку featureA в master, Git увидит конфликт – в одной версии строка изменилась на 60, в другой на 45, и он не знает, какую взять.

При выполнении `git merge featureA` (находясь на master) вывод будет:

```
Auto-merging config.txt  
CONFLICT (content): Merge conflict in config.txt  
Automatic merge failed; fix conflicts and then commit the result.
```

Состояние репозитория теперь особое: слияние не завершено. Чтобы увидеть конфликтующие файлы, выполните `git status`:

```bash
$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add <file>..." to mark resolution)
	both modified:   config.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

В секции *Unmerged paths* указан файл с конфликтом: *both modified: config.txt* означает, что и в HEAD (master), и в merging ветке (featureA) файл был изменен. Git пометил конфликт прямо внутри файла `config.txt`. Если открыть его, там будут специальные маркеры:

```diff
<<<<<<< HEAD
timeout = 45
=======
timeout = 60
>>>>>>> featureA
```

Структура такая:
- Все, что между `<<<<<<< HEAD` и `=======` – это содержимое файла в текущей ветке (на которую мержим, у нас master) в конфликтующем участке.
- Все, что между `=======` и `>>>>>>> featureA` – содержимое из сливаемой ветки (featureA) в этом участке.
- Маркеры `<<<<<<<`, `=======`, `>>>>>>>` показаны буквально в файле.

В нашем примере верхняя часть (HEAD) имеет `timeout = 45`, нижняя (featureA) – `timeout = 60`. Теперь задача разработчика – вручную отредактировать файл, решив, какое значение нужно оставить (или придумать свое, возможно объединить изменения).

**Как решить конфликт:**
1. Откройте конфликтный файл в текстовом редакторе. Найдите маркеры `<<<<<<` и `>>>>>>`.
2. Решите, что оставить. Вы можете выбрать одну из версий полностью, либо внести комбинированное правку. Например, решить, что правильным будет `timeout = 60` (версия featureA) и проигнорировать `45`. Либо наоборот, или даже написать `timeout = 50` как компромисс. Главное – привести файл к нужному корректному состоянию **и удалить все маркеры конфликта**.
3. Сохраните отредактированный файл. В нашем случае мы решили оставить `60`:
   ```
   timeout = 60
   ```
   (все строки `<<<<<<`, `======`, `>>>>>>` удалены, осталась только финальная строка).
4. Теперь сообщим Git, что конфликт решен: добавим файл в индекс:
   ```bash
   git add config.txt
   ```
   После этого `git status` покажет, что *all conflicts fixed, but you are still merging*.
5. Завершим слияние, зафиксировав результат:
   ```bash
   git commit -m "Merge branch 'featureA', resolve timeout conflict"
   ```
   Если не указать `-m`, Git откроет редактор с автосгенерированным сообщением слияния (список конфликтных файлов), вы можете его отредактировать. С флагом `-m` мы сами описали, что сделали.

После этого конфликт считается разрешенным, и в истории появится обычный merge-коммит. 

**Отмена слияния:** Если при возникновении конфликта вы передумали сливать (или сделали что-то не то), можно отменить незавершенное слияние: `git merge --abort`. Эта команда вернет ветку в состояние до начала `git merge` (откатит изменения, которые Git успел объединить, и уберет метки конфликтов). Важно вызывать ее *до* того, как вы пытаетесь решить конфликт через add/commit.

**Конфликты при rebase:** Аналогично могут возникнуть при `git rebase`. Разница в командах разрешения: во время rebase, после ручного исправления файла, нужно выполнить `git add <file>` и затем `git rebase --continue` (а не `git commit` – commit при rebase делает сам Git). Если передумали – `git rebase --abort` аналогично откатит к исходному состоянию.

**Другие типы конфликтов:** Большинство конфликтов – это содержимое файлов (*content conflict*). Но бывают и конфликтующие удаления (когда в одной ветке файл изменен, а в другой удален), конфликты имен (переименование одного файла в разные имена). Git тоже попытаться укажет: например *both added* (если оба добавили файл с одинаковым именем), или *deleted by them/us*. Разрешаются они также вручную: либо восстановить/удалить нужный файл, либо переименовать.

**Инструменты для разрешения конфликтов:** В реальных проектах файлы могут быть большие, и вручную искать разницу неудобно. Существуют инструменты визуального слияния (merge tool), которые показывают версии бок о бок и позволяют кликнуть, что оставить. Git интегрируется с разными mergetool (kdiff3, Meld, VS Code и др.). Команда `git mergetool` после конфликта откроет инструмент, если он настроен. Но принцип работы тот же – нужно выбрать итоговое содержимое файла.

В контексте нашей лекции важно понять: **конфликт – это нормально**, это значит, что двое людей работали над одной частью кода. Решение конфликта – ответственность человека, Git лишь указывает место. После небольшой практики вы будете быстро справляться с конфликтами.

Совет: старайтесь делать коммиты и слияния чаще, тогда вероятность больших конфликтов снижается. Также обсуждайте с командой возможные пересечения в работе, чтобы минимизировать одновременные правки одного участка.

## 9. `cherry-pick`, `revert` и `reset`: выборочное применение коммитов, откат изменений

На более продвинутом этапе работы возникают ситуации, когда нужно выборочно перенести изменения или отменить эффекты коммитов. Git предоставляет для этого специальные команды: **cherry-pick**, **revert** и уже знакомый **reset** (в другом контексте).

### Cherry-pick: применить отдельный коммит

**Cherry-pick** дословно "выбрать вишенку" – позволяет взять один (или несколько) коммитов из одной ветки и применить его на другой ветке. Представьте, у вас есть ветка `experiment` с 5 коммитами, из которых только один содержит полезный багфикс, а остальное – не готовый код. Вам не хочется мержить всю ветку, но нужно перенести фикс в основную ветку. Cherry-pick идеально подходит.

Пример: в ветке `experiment` есть коммит с хешем `a1b2c3d` который исправляет ошибку. Мы переключаемся на ветку, куда хотим перенести этот коммит (например, `master`) и выполняем:

```bash
git cherry-pick a1b2c3d
```

Git возьмет изменения, внесенные коммитом `a1b2c3d`, и совершит новый коммит в текущей ветке с теми же изменениями (автором по умолчанию будет оригинальный автор, но дата текущая, и новый коммит получит новый хеш). Если возникают конфликты при применении (в тех местах, где база ветки отличается), Git попросит разрешить их так же, как при merge.

Можно cherry-pick несколько коммитов за раз (указав диапазон или несколько хешей). Например, `git cherry-pick C1 C2 C3` применит три коммита последовательно. Или `git cherry-pick A..B` применит все коммиты от A (исключая A) до B (включая B).

После cherry-pick в истории текущей ветки появится новый коммит, содержание которого идентично перенесенному. Обратите внимание: cherry-pick дублирует изменения, и если потом вы все-таки объедините полностью ветки, могут возникнуть дубликаты (Git обычно распознает, что коммит уже был применен, если истории сводятся).

Cherry-pick часто используют при переносе багфиксов из одной версии проекта в другую (например, из ветки разработки в ветку релиза). Это инструмент точечного маневра.

### Revert: откат коммита (через обратный коммит)

Команда **revert** создает новый коммит, отменяющий изменения указанного коммита. Важно понимать: `git revert` **не удаляет** существующий коммит из истории, а как бы накладывает на него противоположный патч. Это удобно, когда нужно отменить изменение, которое уже отправлено в общий репозиторий, не переписывая историю (что нежелательно, если коммит уже разослан другим).

Например, вы обнаружили, что коммит `f5e4d3c` добавил в код ошибку. Решение: вернуться к состоянию до него. Можно сделать:

```bash
git revert f5e4d3c
```

После этого Git откроет редактор для ввода сообщения коммита (по умолчанию будет "Revert " и оригинальное сообщение, плюс описание). Вы можете отредактировать или оставить. Сохраните и выйдите – Git создаст новый коммит, который вносит обратные изменения. То есть, если коммит `f5e4d3c` добавил строку, коммит-revert ее удалит; если изменил 10 строк, revert изменит их обратно; если удалил файл – revert восстановит файл (с содержимым из предыдущей версии). В `git log` появится запись, например:

```
commit 3a1c2b4 (HEAD -> master)
Author: ...
Date: ...

    Revert "Add experimental feature X"

    This reverts commit f5e4d3c...
```

Тем самым, история сохранилась линейной, но эффект того проблемного коммита нивелирован новым коммитом.

Revert тоже может столкнуться с конфликтами (если последующие коммиты затрагивали те же места). Придется решать вручную, как при merge.

Отметим отличие: `git revert` обычно применяют к уже **зафиксированным и опубликованным** изменениям, когда нельзя их просто удалить из истории, а нужно **отменить в новом коммите**. 

### Reset: перемещение HEAD (и отмена коммитов)

**Reset** – мощная и несколько опасная команда, которая двигает указатель HEAD и, опционально, изменяет индекс и рабочую директорию. Reset бывает трех основных видов (по флагам):

- `git reset --soft <commit>` – переместить HEAD на указанный `<commit>`, **оставив все изменения** после него в индексе. Проще: удаляет из истории последующие коммиты, но изменения, которые они содержали, остаются *готовыми к коммиту*. Используется, например, чтобы "слить" несколько последних коммитов в один: вы откатываете HEAD на более ранний коммит (сохранив изменения), а затем делаете новый коммит, включающий все изменения разом.
- `git reset --mixed <commit>` (по умолчанию, если флаг не указан) – перемещает HEAD и **оставляет изменения в рабочей директории, но убирает из индекса**. Т.е. коммиты "отматываются", изменения остаются как незакоммиченные. Это можно использовать, чтобы отменить коммит и вернуться к состоянию, как будто вы внесли изменения, но еще их не коммитили. После этого вы можете внести правки и закоммитить заново. (Если не указывать опций, `git reset <commit>` делает именно это поведение).
- `git reset --hard <commit>` – **полностью сбрасывает** и HEAD, и индекс, и рабочую директорию к `<commit>`. Внимание: все несохраненные изменения, а также коммиты после указанного, будут потеряны (если не имеют других ссылок). Рабочая папка откатится к состоянию того коммита. Этот вариант используют, когда нужно **полностью отменить изменения безвозвратно**, например, вы попробовали что-то, закоммитили, но решили начать сначала.

Обычно `<commit>` указывают как ссылку вроде HEAD~1 (предыдущий коммит), или имя ветки, или конкретный хеш.

**Пример (reset --mixed):** Вы сделали 3 коммита, но хотите отменить последний, потому что он ошибочен и вы желаете внести корректировки и закоммитить по-другому. Текущая история: A -> B -> C (HEAD на C). Выполните:

```bash
git reset HEAD~1
```

HEAD~1 значит "родитель HEAD", т.е. коммит B. После команды HEAD будет указывать на B, а изменения из C останутся в рабочей директории (и уже не в индексе, т.к. mixed). `git status` покажет эти файлы как *Changes not staged for commit*. Вы можете отредактировать что нужно, затем снова `git add` и `git commit` – получится новый коммит D. История станет A -> B -> D. Коммита C больше нет на ветке (но пока что его можно найти по хешу, т.к. он не удалился мгновенно из базы, но на него нет ссылки).

**Пример (reset --hard):** Вы нахулиганили в коде, у вас куча измененных файлов и пару лишних коммитов, и вы хотите вернуться к состоянию 5 коммитов назад, выкинуть все, что было сделано. Допустим HEAD на коммите G, а надо откатиться к коммиту C. Вы делаете:

```bash
git reset --hard C
```

Мгновенно HEAD указывает на C, рабочая директория откатывается. Коммиты D, E, F, G исчезают из текущей ветки. Они остаются в базе данных Git, пока сборщик мусора их не уберет, но без специальных усилий вы их не увидите. Ветки, удаленные таким способом, трудно восстановить, поэтому с `--hard` нужно быть очень осторожным. Лучше применять его только к локальным, никому не видимым изменениям, или когда у вас есть бэкап.

**Reset vs Revert:** Reset стирает историю (линейно перемещает ветку назад), поэтому его нельзя применять на общих ветках, где уже кто-то видел те коммиты. Revert же создаст новый коммит и сохранит историю, поэтому безопасен для публичных веток. Правило: **reset для частных откатов, revert для публичных**. Если вы в своей локальной ветке наделали лишнего – reset. Если вы уже запушили в origin/main ошибку – делайте revert.

### Практические примеры:

- **Отменить локальный коммит:** `git reset HEAD~1` – откатить один коммит, оставить изменения. Или `git reset --hard HEAD~1` – откатить коммит и выбросить изменения (без возможности вернуть).
- **Отменить публичный коммит:** `git revert HEAD` (если это последний) или указать хеш. Это добавит коммит-откат.
- **Вытащить конкретный патч:** `git cherry-pick <hash>`.
- **Несколько cherry-pick:** Например, у вас ветка hotfix, и нужно перенести 3 коммита в другую ветку: можно сделать `git cherry-pick hash1 hash2 hash3` или диапазон `git cherry-pick A^..C` (взять все от родителя A до C включительно).

Наконец, еще одна разновидность: `git reset` без указания коммита, но с файлом, мы уже видели (`git reset HEAD file`) – используется для unstaging. Cherry-pick и revert работают только с коммитами.

Все эти команды изменяют историю или применяют патчи. Поэтому всегда думайте дважды и желательно делайте резервную копию ветки (например, `git branch backup`) перед рискованными операциями, чтобы можно было вернуться.

## 10. Работа с удалёнными репозиториями: `clone`, `push`, `pull`, `fetch`, `pull requests`

В реальных проектах используется не только локальный репозиторий, но и **удаленный (remote)** – общий для команды или для резервного копирования. Понимание работы с удаленными репозиториями необходимо для совместной работы.

### Клонирование репозитория (`git clone`)

Чтобы начать работать с существующим проектом, вы обычно **клонируете** удаленный репозиторий. Команда:

```bash
git clone <URL>
```

Например: `git clone https://github.com/user/project.git`. Эта команда делает следующее:
- Создает папку `project` (по умолчанию имя берется из репозитория, но можно указать другое).
- Загружает **всю историю** репозитория по адресу URL.
- Настраивает `origin` как имя удаленного репозитория.
- По умолчанию, вытаскивает ветку по умолчанию (main/master) и делает ее текущей.

После успешного клонирования у вас есть полностью функциональный локальный репозиторий, связанный с удаленным `origin`. `git remote -v` покажет список настроенных удаленных: обычно `origin` с fetch и push URL. Как правило, origin указывает на тот же URL, откуда вы клонировали, и используется и для чтения (pull/fetch) и для записи (push).

### Связь локальных и удаленных веток

Когда вы клонируете, Git автоматически настраивает **tracking** (отслеживание) для главной ветки: локальная `main` будет отслеживать `origin/main`. Это значит, что команды `git pull` и `git push` по умолчанию знают, откуда тянуть и куда пушить для этой ветки.

Если вы создаете новые ветки, их можно тоже связать с удаленными при первом push (флаг `-u`, упомянем ниже).

### Отправка изменений на сервер (`git push`)

После того, как вы сделали коммиты локально, чтобы поделиться ими, нужно **отправить** их в удаленный репозиторий. Команда:

```bash
git push <remote> <branch>
```

Чаще всего `git push origin master` (или `main`). Если ветка *tracking* настроена, достаточно `git push` (Git поймет, что текущая ветка связана с origin/master, и пушит туда).

При пуше Git отправит новые коммиты на сервер. Требуется доступ: обычно аутентификация (SSH-ключ или ввод логина/токена, в зависимости от настройки удаленного). Если кто-то еще запушил изменения раньше вас, и ваш push не содержит их, сервер отклонит push (так называемый *non-fast-forward update*). В таком случае нужно сначала получить изменения (pull), объединить их с вашими (merge/rebase), и только потом повторить push.

Когда push проходит успешно, удаленный репозиторий обновляет свою ветку. Ваши коллеги смогут получить ваши изменения через pull/fetch.

**Настройка upstream (tracking) ветки:** При первом пуше новой ветки, Git подскажет, что удаленная ветка с таким именем отсутствует. Можно создать ее, выполнив:

```bash
git push -u origin new-feature
```

Флаг `-u` (upstream) говорит: запомнить, что локальная ветка `new-feature` отслеживает удаленную `origin/new-feature`. После этого, `git push` и `git pull` на этой ветке будут знать куда именно отправлять/забирать данные.

### Получение изменений (`git pull` и `git fetch`)

**`git fetch`:** команда для **загрузки** изменений с удаленного репозитория, без слияния с вашей локальной работой. Она обращается к серверу, получает все новые объекты (коммиты, ссылки) и обновляет ссылки в вашем локальном репозитории, но не трогает ваши текущие ветки. Например, `git fetch origin` обновит удаленные ветки `origin/main`, `origin/featureX` и т.д. до актуального состояния, но ваши локальные копии останутся на месте. Вы можете посмотреть, какие коммиты пришли, через `git log origin/main` и решить, что с ними делать (слиять или нет).

**`git pull`:** более высокоуровневая команда, которая по сути делает `fetch` + автоматическое слияние (merge или rebase, по настройке). Обычно используют `git pull` для быстрого обновления текущей ветки. Например, на ветке master, связанной с origin/master, `git pull`:
1. Скачает новые коммиты с сервера (fetch).
2. Затем автоматически сделает слияние origin/master в вашу master (или rebase ваших коммитов на origin/master, если так настроено). По умолчанию Git делает merge.

В результате, после `git pull`, ваша локальная ветка будет содержать все обновления. Возможно, при этом будут коммиты слияния или возникнут конфликты, которые нужно решить, как обычно.

Некоторые предпочитают разделять эти процессы: сначала `git fetch`, затем `git merge origin/master` вручную. Это дает больше контроля (например, вы увидите заранее, что изменений пришло, и можете решить, rebase или merge). Тем не менее, для простоты `git pull` – часто используемая команда.

**Пример последовательной работы в команде:**
- Вы клонировали репозиторий. Начали новую ветку, сделали коммиты.
- Чтобы синхронизироваться с коллегами, вы делаете `git pull origin master` на мастер – подтягиваете последние их изменения.
- Переключаетесь на свою ветку, возможно делаете `git merge master` или `git rebase master` чтобы интегрировать обновления.
- После проверки, пушите свою ветку: `git push -u origin my-feature`.
- На сервере (например, GitHub) появится ветка `my-feature`. Вы можете создать Pull Request для ее слияния (см. ниже).
- Ваши коллеги могут выполнить `git fetch origin` и увидят новую ветку, или `git pull` если они хотят сразу ее получить локально.

### Pull Request (запрос на слияние)

**Pull request (PR)** – понятие, выходящее за рамки чисто Git, но неотъемлемое в современных workflow. Сама по себе Git не знает о "pull requestах" – это функция хостингов (GitHub, GitLab, Bitbucket и др.), которая облегчает обсуждение и принятие изменений.

Сценарий: вы форкнули репозиторий или работаете в отдельной ветке в общем репозитории, и хотите, чтобы ваши изменения включили в основную ветку (обычно `master`/`main`). Вы создаете Pull Request – по сути, запрос владельцам проекта: "затяните мои коммиты в ваш репозиторий". Это сопровождается возможностью просмотреть изменения, оставить комментарии (код-ревью), и затем нажатием кнопки слить ветку.

На практике, **pull request** – это удобный интерфейс для команды `git merge`. Например, на GitHub, когда PR одобрен, можно сделать "Merge", и GitHub сам выполнит merge (или rebase, или squash, в зависимости от выбранного способа) ветки автора в целевую ветку. После этого изменения появляются в главной ветке и репозиторий обновляется.

Если вы работаете в команде через PR, то ваш процесс:
- Сделали ветку, закоммитили изменения.
- Запушили ветку на сервер (origin).
- В интерфейсе Git-хостинга открыли новый Pull Request, выбрав вашу ветку и целевую (например, origin/master).
- Прошли ревью, возможно сделали дополнительные коммиты (их просто пушите в ту же ветку – PR автоматически обновится).
- После согласия – нажимаете Merge. Либо это делает ответственный лицо. 
- Ваша ветка сливается, и обычно потом удаляется.

Стоит отметить, что **pull request** на некоторых платформах называются по-другому: например, в GitLab – *Merge Request*, но суть та же.

### Дополнительные команды для удаленных

- `git remote add <name> <url>` – если у вашего локального репо не было удаленного, или вы хотите добавить еще один (например, `upstream` для форка), этой командой добавляется новый remote. После этого можно fetch/push по имени.
- `git remote remove <name>` – удалить привязку удаленного.
- `git branch -u origin/branch` – установить ветку отслеживания (upstream) для текущей ветки постфактум.
- `git push <remote> --delete <branch>` – удаление ветки на удаленном репозитории (например, после слияния PR обычно чистят удаленные ветки).
- `git pull --rebase` – как говорили, подтянуть изменения с перебазированием вместо merge.

В повседневной работе в небольшой команде часто хватает: `pull` перед началом работы, коммитить, `push` по готовности, открыть PR. 

Подведем итог: **`clone`** – получить репо, **`fetch`/`pull`** – получить изменения, **`push`** – отправить изменения. Убедитесь, что настроили имя удаленного (обычно origin) и ветки tracking (Git обычно делает это автоматически при clone и первом push). **Pull request** – это внешняя надстройка для удобного сотрудничества и код-ревью, обычно осуществляемая на платформе, а не самой командой Git.

## 11. История и сравнение версий (`log`, `diff`)

Мы уже познакомились с `git log` для просмотра истории и `git diff` для просмотра изменений. Здесь обобщим и добавим некоторые возможности, полезные для анализа прошлого.

### Просмотр истории (`git log`)

`git log` имеет множество опций форматирования вывода. Некоторые полезные примеры:
- **Короткий лог:** `git log --oneline` – каждый коммит в одну строку (показывает первые 7 символов хеша и сообщение коммита). Удобно для общего обзора, особенно в графе веток.
- **Граф веток:** `git log --oneline --graph --all` – отобразит ASCII-дерево всех веток (--all включает и необработанные). Вы увидите звездочки и линии, показывающие историю ветвления и слияния.
- **Автор/дата/фильтрация:** `git log --author="Alice"` покажет только коммиты, где автор содержит "Alice". `git log --since="2025-01-01"` (или `--after`) – коммиты за период. `--grep="фикс бага"` – поиск по сообщению коммита. Эти фильтры можно комбинировать.
- **Показ изменений:** `git log -p` – кроме информации о коммите, вывести *patch* (дифф) каждого коммита. Это подробно, но бывает полезно увидеть, что конкретно изменилось.
- **Статистика:** `git log --stat` – вместо полного диффа покажет список измененных файлов и суммарно добавленные/удаленные строки по каждому (как при merge мы видели).
- **Конкретная ветка или файл:** `git log main` – история только ветки main (хотя по умолчанию так). `git log feature..main` – что было сделано в main после расхождения с feature. `git log -- path/to/file` – история изменений конкретного файла.

Например, если вы хотите увидеть, когда в файл `config.txt` вносились изменения и какие, можно сделать:
```
git log -p -- config.txt
```
Это выдаст все коммиты, затрагивавшие config.txt, с патчами.

### Сравнение изменений (`git diff`)

Команда `git diff` очень гибкая:
- Без параметров (в чистом виде, когда *не в процессе слияния*) она сравнивает **рабочую директорию** с индексом, или, если индекс не пуст, то с HEAD. Обычно это показывает несохраненные изменения.
- `git diff --staged` (или `--cached`) – сравнить индекс с HEAD, т.е. то, что готово к коммиту, с последним коммитом.
- `git diff HEAD` – сравнить **рабочую директорию** (все изменения, даже не добавленные) с HEAD. Можно добавить `--name-only` чтобы просто список файлов с изменениями вывести.
- С указанием коммитов: `git diff <commit1> <commit2>` – разница между двумя коммитами (можно использовать хеши, теги или HEAD~N). Например, `git diff master featureX` покажет что нужно применить к master, чтобы получить featureX (если указать наоборот, поменяется знак +/-, но фактически можно прочесть).
- `git diff <commit> <file>` – сравнить версию файла в указанном коммите с рабочей директорией.
- `git diff branchA..branchB` – обычно аналогично `git diff branchA branchB` (показывает изменения, чтобы получить из A -> B).
- `git diff branchA...branchB` (три точки) – немножко другое: сравнить состояния двух веток относительно их общего предка (показывает изменения, внесенные в одну ветку и другую с момента разветвления). Это сложнее, на начальном этапе не обязательно.

Diff показывает разницу в формате *unified diff*: по контексту вы уже видели, строки с "-" удалены, "+" добавлены. Также указывается, какие функции или строки вокруг (для ориентирования).

Помимо встроенного diff, Git позволяет запускать графические дифф-программы (`git difftool`), которые удобны для больших изменений.

### Просмотр конкретной версии (checkout детач)

Если вы хотите **посмотреть состояние проекта** на момент конкретного коммита или тега, можно использовать:

```bash
git checkout <commit-hash>
```

Напрямую указав хеш или тег вместо имени ветки, вы входите в detached HEAD режим. Это полезно, чтобы, например, собрать старую версию программы или протестировать что-то. Вы можете после этого вернуться `git checkout master`. Если в detached режиме сделать коммит, он останется вне именованной ветки (его не потерять, но чтобы его не потерять, нужно потом либо создать ветку, либо переместить HEAD обратно).

Альтернатива – команда `git show <commit>` – она покажет информацию о коммите и патч (equivalent to `git log -p -1 <commit>`). Также `git show <commit>:<path>` выведет содержимое конкретного файла в указанном коммите (полезно, чтобы посмотреть старую версию файла без переключения всей ветки).

### Blame и другие исследования

Ещё одна команда истории – `git blame <file>` – показывает строчно, какой коммит (и автор) последним изменил каждую строку файла. Очень удобно для поиска, кто внедрил определенную строку или баг. Вывод: номер строки, сокращенный хеш, имя автора, дата и сама строка. Можно использовать опции типа `-L 40,60` чтобы blame только участок строк.

`git tag` – не совсем про историю, но обычно релизы помечаются тегами. `git tag -l` покажет список тегов, `git show <tag>` покажет коммит, связанный с тегом (тег обычно указывает на коммит, а аннотированный тег содержит еще имя автора тега и сообщение). Вы можете checkout на тег (это detached HEAD).

### Примеры сценариев:

- Вы влили ветку и хотите убедиться, какие коммиты вошли: `git log master ^feature` (покажи коммиты на мастере, исключая те, что были в feature до слияния).
- Нужно понять, между версией 1.0 и 1.1 что поменялось: если есть теги `v1.0` и `v1.1`, то `git diff v1.0 v1.1` или `git log v1.0..v1.1`.
- Перед код-ревью, хотите посмотреть патч, который отправил коллега в PR: если вы fetch его ветку как origin/feature, можно `git diff origin/master origin/feature` или `git log origin/master..origin/feature`.

Git – очень богат на возможности анализа истории. Для начала запомните `log` (с разными ключами) и `diff` (для рабочего копирования и между коммитами). А blame и tags пригодятся по мере необходимости.

## 12. Лучшие практики работы с Git

Наконец, обсудим некоторые **лучшие практики**, которые выработались в сообществе разработчиков при использовании Git. Соблюдение этих рекомендаций поможет поддерживать историю чистой и проект организованным.

- **Делайте частые коммиты с понятными сообщениями.** Коммиты должны отражать логические единицы изменений. Избегайте монолитных коммитов, где смешаны правки, не связанные друг с другом. Оптимально, когда сообщение коммита отвечает на вопрос *"Что сделано и зачем?"*. Пример хорошего сообщения: `Fix issue #123: handle null pointer in user login` – ясно, что исправлено. Плохой пример: `Update` или `Fix bug` – слишком размыто. Также старайтесь писать сообщение в повелительном наклонении (стандарт в Git-сообщениях): "Add feature X", "Update documentation".
- **Следите за чистотой истории (особенно в главной ветке).** История коммитов будет читаться другими разработчиками. По возможности избегайте лишних "мусорных" коммитов вроде "WIP", "Исправил опечатку", объединяйте их перед слиянием в основную ветку. Инструментом для этого служит interactive rebase (squash). Например, вы работали в фича-ветке и накопили 10 коммитов, часть из них мелкие исправления. Перед созданием PR можно выполнить `git rebase -i` и объединить связанные коммиты или отредактировать их сообщения. Это делает историю более линейной и понятной.
- **Не переписывайте историю, которая уже отправлена в общий репозиторий.** Правило: после `git push` в main (или любую общую ветку) избегайте `git reset` или `rebase`, т.к. это создаст несогласованность с репозиторием коллег. Если нужно отменить – используйте `git revert`. Переписывать историю можно в своих фича-ветках *до* их слияния (например, вы запушили PR, вам сделали замечания – вы можете либо добавить новые "fix" коммиты, либо перед пушем поправить существующие коммиты через rebase и пушнуть с `--force-with-lease`, но это требует понимания и осторожности).
- **Используйте `.gitignore`.** Файл `.gitignore` в корне репозитория (или в отдельных папках) позволяет указать, какие файлы Git должен игнорировать (не предлагать добавить и не отслеживать). Сюда обычно включают:
  - Сгенерированные артефакты сборки: бинарные файлы, объекты, логи, временные файлы. Например: `*.o`, `*.class`, `/bin/`, `/dist/`.
  - Файлы настроек IDE, среды: `.vscode/`, `.idea/`, файлы проекта Xcode, etc.
  - Секретные или средовые файлы: например, файлы конфигурации с паролями, `*.pem`, `.env` файлы с переменными окружения, локальные базы данных.
  - Кэш, временные: `*.log`, `*.tmp`, и т.п.
  
  Пример `.gitignore` для С#:
  
 ```
# Common IntelliJ Platform excludes

# User specific
**/.idea/**/workspace.xml
**/.idea/**/tasks.xml
**/.idea/shelf/*
**/.idea/dictionaries
**/.idea/httpRequests/

# Sensitive or high-churn files
**/.idea/**/dataSources/
**/.idea/**/dataSources.ids
**/.idea/**/dataSources.xml
**/.idea/**/dataSources.local.xml
**/.idea/**/sqlDataSources.xml
**/.idea/**/dynamic.xml

# Rider
# Rider auto-generates .iml files, and contentModel.xml
**/.idea/**/*.iml
**/.idea/**/contentModel.xml
**/.idea/**/modules.xml

*.suo
*.user
.vs/
[Bb]in/
[Oo]bj/
_UpgradeReport_Files/
[Pp]ackages/

Thumbs.db
Desktop.ini
.DS_Store
```

  Всегда настраивайте gitignore **до** первого коммита, чтобы не пришлось потом вычищать лишнее. Если вы случайно закоммитили лишний файл, можно его удалить из истории (`git rm --cached filename` и добавить в .gitignore, затем коммит).
- **Работайте в ветках для новых фич и багфиксов.** Не ведите разработку прямо в `master`/`main` (если только проект очень маленький и вы один). Ветки позволяют изолировать работу, проводить код-ревью через PR и не ломать стабильную ветку. Обычно принята схема: основная ветка (main) всегда в рабочем состоянии; новые возможности – в отдельных feature-ветках; релизные версии – в отдельной ветке или помечаются тегами. 
- **Регулярно интегрируйтесь с основной веткой.** Не держите длительно отрастающие ветки, которые сложно потом сливать. Периодически обновляйте свою ветку изменениями из main (через merge или rebase), чтобы конфликтов было меньше. И наоборот – не копите на master много изменений без релизов, чаще выпускайте небольшие обновления (если это релизной стратегии касается).
- **Перед тем как `push`, выполните `pull`.** Это простое правило убережет от многих конфликтов. Если вы не единственный, кто пушит в ветку, всегда сначала подтяните последние изменения: `git pull` (возможно с `--rebase`), убедитесь, что ваш код совместим, и только затем пушьте. Git обычно не даст запушить, если вы позади удаленной ветки, но лучше самостоятельно быть проактивным.
- **Комментируйте и документируйте, что делаете.** Хотя это не прямая функция Git, но в процессе code review, истории коммитов – вся команда должна понимать, зачем те или иные изменения были внесены. Хорошая история коммитов — это живая документация проекта. Новичок, изучающий код, может прочитать сообщения и понять ход мыслей предыдущих разработчиков.
- **Backup и CI:** Настройте удаленный репозиторий (GitHub, GitLab или собственный сервер) и регулярно пушьте туда. Это защитит от потери данных. Кроме того, интегрируйте CI (непрерывную интеграцию) – чтобы на каждый push запускались тесты, линтеры. Это не столько про Git, но тесно связано: например, не стоит держать неопубликованные коммиты слишком долго – пушьте чаще, пусть система проверяет, все ли в порядке.



