

# Twelve‑Factor App: методология разработки облачных приложений

## Введение

**Twelve‑Factor App** (методология «Двенадцать факторов») – это набор принципов и практик, сформулированный компанией Heroku в 2011 году для создания **современных веб-приложений** ([Обзор методологии “The 12-Factor Applications”](https://pryazhnikov.com/ru/12factor-apps/#:~:text=%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9%20%D0%B8%20%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D0%BE%D0%B2%2C%20%D0%B2%D1%8B%D0%BF%D1%83%D1%89%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9%20%D0%BA%D0%BE%D0%BC%D0%BF%D0%B0%D0%BD%D0%B8%D0%B5%D0%B9,%D0%B4)). Соблюдение этих принципов позволяет разрабатывать **SaaS-приложения** (software-as-a-service), которые легко масштабировать, удобно развёртывать и поддерживать в разных средах ([Обзор методологии “The 12-Factor Applications”](https://pryazhnikov.com/ru/12factor-apps/#:~:text=%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9%20%D0%B8%20%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D0%BE%D0%B2%2C%20%D0%B2%D1%8B%D0%BF%D1%83%D1%89%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9%20%D0%BA%D0%BE%D0%BC%D0%BF%D0%B0%D0%BD%D0%B8%D0%B5%D0%B9,%D0%B4)). Изначально методология продвигалась Heroku для приложений на их облачной платформе, однако со временем она стала популярной во всём ИТ-сообществе как язык-независимый стандарт лучших практик.

**Для чего нужны эти принципы?** Цель Twelve-Factor методологии – решить распространённые проблемы при разработке и эксплуатации облачных приложений. Приложения, созданные по этим принципам, готовы к **горизонтальному масштабированию**, **непрерывному развертыванию** и работе на **современных облачных платформах** ([Простыми словами о Twelve-Factor App / Хабр](https://habr.com/ru/articles/261171/#:~:text=%D0%98%D0%B7%D0%B2%D0%B5%D1%81%D1%82%D0%BD%D1%8B%D0%B9%20%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B9%D0%B4%D0%B5%D1%80%20heroku%20%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%B8%D0%B2%D0%B0%D0%B5%D1%82%20%D0%BC%D0%B0%D0%BD%D0%B8%D1%84%D0%B5%D1%81%D1%82%2C,%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8%20%D0%BE%D0%BF%D0%B8%D1%81%D1%8B%D0%B2%D0%B0%D1%8E%D1%82%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%2C%20%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5%20%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D1%8B)). Иными словами, 12-факторные приложения изначально спроектированы с учётом требований облака: они могут переноситься между серверами и контейнерами без ошибок, быстро адаптироваться под новые окружения, выдерживать рост нагрузки и частые релизы. Даже с появлением Docker и Kubernetes эти принципы остаются актуальными – контейнеры и оркестраторы значительно изменили способы упаковки и деплоя, но **концепция 12 факторов по-прежнему важна** для обеспечения надёжности, гибкости и масштабируемости приложений ([Концепция Twelve-Factor App и Kubernetes / Хабр](https://habr.com/ru/companies/slurm/articles/785658/#:~:text=%D0%A1%20%D0%BC%D0%BE%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%20%D0%BF%D1%83%D0%B1%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%B8%20%D0%BA%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%86%D0%B8%D0%B8%20Twelve,%D0%B0%D0%BA%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%20%D0%B2%20%D1%81%D0%BE%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%BC%20%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%BC%20%D1%81%D1%82%D0%B5%D0%BA%D0%B5)) ([Концепция Twelve-Factor App и Kubernetes / Хабр](https://habr.com/ru/companies/slurm/articles/785658/#:~:text=Twelve,%D0%B8%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BD%D0%BE%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C%20%D0%BD%D0%B0%20%D0%B3%D0%BE%D0%B4%D1%8B%20%D0%B2%D0%BF%D0%B5%D1%80%D1%91%D0%B4)).

Ниже перечислены *типичные проблемы*, с которыми сталкиваются команды без применения 12 факторной методологии:

- **Среды не консистентны:** приложение «работает на моей машине», но падает на сервере из-за отличий в настройках или отсутствующих библиотек.
- **Конфигурация зашита в коде:** пароли, строки подключения и другие параметры внедрены прямо в код/файлы, из-за чего развёртывание на другое окружение требует изменения кода (риск ошибок и утечек секретов).
- **Сложная масштабируемость:** чтобы запустить второй экземпляр приложения, приходится вручную настраивать состояние (например, сессии) или зависимые сервисы, а горизонтальное масштабирование затруднено.
- **Логи и отладка:** логи разбросаны по файлам на серверах, требуется вручную собирать и ротировать их, что усложняет мониторинг и отладку.
- **Долгие деплои и простои:** сборка и деплой выполняются вручную, процесс медленный и подвержен человеческим ошибкам; при падении приложения требуется много времени на перезапуск и восстановление состояния.

Методология Twelve-Factor App адресует эти проблемы с помощью двенадцати ключевых принципов. В этой лекции мы рассмотрим каждый фактор: **что он из себя представляет, какую проблему решает и как применить его на практике**. Мы приведём простые объяснения и примеры на C# и ASP.NET Core, а также покажем, как Docker и другие инструменты .NET экосистемы помогают следовать 12-факторным принципам. Кроме того, разберём **полный цикл разработки и деплоя** 12-факторного приложения и предложим небольшое практическое задание для закрепления материала. 

*(Примечание: Хотя изначально методология описана в терминах веб-приложений, её принципы применимы к приложениям на любом языке и архитектуре, в том числе к .NET.)*

## Краткий обзор 12 факторов

Принципы Twelve-Factor App можно кратко перечислить следующим образом:

1. **Кодовая база (Codebase):** Одна кодовая база, отслеживаемая в системе контроля версий, обеспечивает многие развёртывания. Это означает, что у каждого приложения один репозиторий кода, из которого развёртываются все его экземпляры (dev, test, prod и т.д.). Общий код между приложениями выносится в библиотеки, подключаемые как зависимости.
2. **Зависимости (Dependencies):** Явное декларирование и изолирование зависимостей. Приложение не должно полагаться на глобально установленное ПО – все нужные библиотеки и пакеты должны быть перечислены в манифесте зависимостей (например, `.csproj` для .NET) и изолированы от системы (например, через контейнер).
3. **Конфигурация (Config):** Храните конфигурацию в окружении. Все параметры, которые различаются между окружениями (URL баз данных, учетные данные, ключи API и т.д.), должны передаваться приложению через переменные среды, а не быть захардкодены в репозитории ([Обзор методологии “The 12-Factor Applications”](https://pryazhnikov.com/ru/12factor-apps/#:~:text=%D0%9A%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%28config%29%20,%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D1%85%20%D1%80%D0%B0%D0%B7%D0%B2%D1%91%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%D0%BD%D0%B8%D1%85%20%D0%B1%D0%B5%D0%B7%20%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BA%D0%BE%D0%B4%D0%B0)).
4. **Сторонние сервисы (Backing Services):** Воспринимайте сторонние сервисы как подключаемые ресурсы. Любые внешние системы – базы данных, очереди, SMTP-серверы, API других приложений – рассматриваются приложением одинаково, будь они локальными или облачными. Доступ к ним конфигурируется через переменные и не требует изменения кода при замене сервиса (например, смена локальной БД на облачную не влияет на код) ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%A1%D1%82%D0%BE%D1%80%D0%BE%D0%BD%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BB%D1%83%D0%B6%D0%B1%D1%8B%20%E2%80%94%20%D1%8D%D1%82%D0%BE%20%D0%B1%D0%B0%D0%B7%D1%8B,%D0%B4%D0%BE%D0%BB%D0%B6%D0%BD%D1%8B%20%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D1%82%D1%8C%D1%81%D1%8F%20%D0%B2%20%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%B8)) ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%97%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0%20%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9%20%D0%B1%D0%B0%D0%B7%D1%8B%20%D0%BD%D0%B0%20Amazon,%D0%B4%D0%BE%D0%BB%D0%B6%D0%BD%D0%BE%20%D0%B2%D0%BB%D0%B8%D1%8F%D1%82%D1%8C%20%D0%BD%D0%B0%20%D0%BA%D0%BE%D0%B4%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F)).
5. **Сборка, релиз, запуск (Build, Release, Run):** Строго разделяйте этапы сборки, релиза и исполнения. Сначала исходный код преобразуется в сборку (билд) — например, компиляция и упаковка приложения. Затем сборка комбинируется с конфигурацией текущего окружения, образуя релиз. И уже релиз запускается в виде одного или нескольких процессов в рабочей среде ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%A0%D0%B0%D0%B7%D0%B2%D0%B5%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20%D1%81%D0%BE%D1%81%D1%82%D0%BE%D0%B8%D1%82%20%D0%B8%D0%B7%20%D1%82%D1%80%D0%B5%D1%85,%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D1%85%20%D1%8D%D1%82%D0%B0%D0%BF%D0%BE%D0%B2)). Никаких изменений кода на этапе запуска быть не должно – новая конфигурация требует нового релиза.
6. **Процессы (Processes):** Приложение запускается как один или несколько **статeless-процессов**. В памяти или на диске процесса может храниться лишь временное, неглобальное состояние; всё постоянное хранится во внешних сервисах (базах, хранилищах) ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B4%D0%BE%D0%BB%D0%B6%D0%BD%D0%BE%20%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA%D0%B0%D1%82%D1%8C%20%D0%BA%D0%B0%D0%BA%20%D0%BE%D0%B4%D0%B8%D0%BD,%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D0%B5%D0%BC%D0%BE%D0%BC%20%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D0%B5)). Это позволяет любому экземпляру процесса обслуживать любой запрос без привязки к предыдущему состоянию (важно, например, для балансировки нагрузки между несколькими экземплярами).
7. **Привязка портов (Port Binding):** Экспортируйте сервис через привязку к порту. 12-факторное веб-приложение не зависит от внешнего веб-сервера (например, IIS, Apache) – оно само содержит веб-сервер как библиотеку и прослушивает порт, выдавая сервисы по HTTP запросу ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BD%D0%B5%20%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D1%82%20%D0%BE%D1%82%20%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B0)). Например, ASP.NET Core-приложение использует встроенный сервер Kestrel и запускается самостоятельно, принимая запросы на определённом порту.
8. **Параллелизм (Concurrency):** Масштабируйте приложение путем запуска множества процессов. Если нужно больше throughput или нужно разделить разные типы нагрузок – запускаются дополнительные экземпляры процессов (веб-процессы, фоновые рабочие процессы и т.д.) вместо масштабирования через «громоздкие» монолиты ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%9C%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%20%D1%81%20%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E%20%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2)). Это достигается как горизонтальным масштабированием (например, несколько контейнеров), так и разделением функциональности по разным процессам.
9. **Утилизируемость (Disposability):** Максимизируйте надежность за счёт быстрого старта и корректного завершения. Приложение должно быстро запускаться (секунды) и корректно отключаться по сигнальным событиям (graceful shutdown) ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%91%D1%8B%D1%81%D1%82%D1%80%D1%8B%D0%B9%20%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA%20%D0%B8%20%D0%BA%D0%BE%D1%80%D1%80%D0%B5%D0%BA%D1%82%D0%BD%D0%BE%D0%B5%20%D0%B7%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B5%D0%BD%D0%B8%D0%B5)). Правильно спроектированный 12-факторный процесс способен пережить внезапные сбои: при падении он не теряет важные данные (потому что они вне процесса), а при перезапуске быстро восстанавливает работу.
10. **Паритет dev/prod (Dev/Prod Parity):** Стремитесь к максимальному сходству между средой разработки, тестирования и продакшена. Разработчики должны регулярно деплоить код (разница во времени – часы, не месяцы), участвовать в релизах и мониторинге, а используемые инструменты и сервисы на локальной машине должны быть максимально близки к боевым ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%A1%D0%B5%D0%B9%D1%87%D0%B0%D1%81%20%D0%BC%D0%B5%D0%B6%D0%B4%D1%83%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%BE%D0%B9%20%D0%B8%20%D1%80%D0%B0%D0%B7%D0%B2%D0%B5%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%D0%BC,%D0%B8%20%D1%80%D0%B0%D0%B7%D0%B2%D0%B5%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%B0%D0%BA%20%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%20%D0%B1%D0%BB%D0%B8%D0%B6%D0%B5)). Это снижает эффект «разработал одно, в проде другое» и позволяет внедрять **непрерывное развёртывание**.
11. **Логи (Logs):** **Логируйте как поток событий**. Приложение не должно само управлять файлами логов – вместо этого оно пишет лог-сообщения в стандартный вывод (stdout) без попыток их сохранять или форматировать ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%9B%D0%BE%D0%B3%D0%B8%20%D0%B2%20stdout)). Сбор и агрегация логов берет на себя окружение (например, Docker/Kubernetes, который собирает stdout всех контейнеров). В результате логи разных инстансов и сервисов можно централизованно просматривать и анализировать в режиме реального времени или после сбоя.
12. **Административные процессы (Admin Processes):** Выполняйте одноразовые административные задачи как отдельные процессы, идентичные основному приложению. Речь о миграциях базы, скриптах наполнения данных, разовых утилитах – их код должен храниться в том же репозитории, использовать те же зависимости и конфигурацию, что и основное приложение ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%A0%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5%20%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B%20%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%20,%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0%D0%BC%2C%20%D1%87%D1%82%D0%BE%20%D0%B8%20%D0%BE%D1%81%D1%82%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%20%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B)). Запускаться они должны в том же окружении, что и основное приложение (например, запуск командой `dotnet run` с определённым аргументом или отдельным контейнером), но *отдельно* от основного веб-процесса.

Эти 12 факторов работают в совокупности, помогая избежать многих ошибок и обеспечивая успешное развёртывание приложения в облаке. Далее мы подробно разберём каждый фактор и способы его реализации на практике.

## I. Кодовая база (Codebase)

**Определение:** Один проект – **один репозиторий** кода, отслеживаемый в системе контроля версий, из которого можно делать множество развёртываний (деплоев) ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%9E%D0%B4%D0%BD%D0%BE%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20%E2%80%94%20%D0%BE%D0%B4%D0%B8%D0%BD%20%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%B9)). Если у вас есть два и более разных приложения, у них **не должна быть общая кодовая база** – каждый сервис имеет свой репозиторий. Общий код выносится в отдельную библиотеку или пакет, подключаемый как зависимость ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%95%D1%81%D0%BB%D0%B8%20%D1%83%20%D0%B2%D0%B0%D1%81%20%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9,%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D0%BC%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC)) ([Простыми словами о Twelve-Factor App / Хабр](https://habr.com/ru/articles/261171/#:~:text=%D0%95%D1%81%D0%BB%D0%B8%20%D1%83%20%D0%B2%D0%B0%D1%81%20%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9,%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D0%BC%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC)).

**Зачем это нужно:** Единая кодовая база обеспечивает **единообразие и отслеживаемость**. Все изменения приложения происходят в одном месте (например, на GitHub), что облегчает командную работу и откат изменений при необходимости. Множество развёртываний (dev, test, staging, prod) из одного репо гарантируют, что в разных средах работает *один и тот же код*, просто в разных конфигурациях или версиях. Это устраняет ситуацию, когда код на продакшене «слегка другой» или содержит правки, не попавшие в контроль версий.

**Пример (C#):** Представим REST API сервис на ASP.NET Core. Правильная организация: весь код сервиса (Controllers, Services, .csproj, Dockerfile, конфиги) хранится в одном git-репозитории, скажем `github.com/org/MyApp`. Разработчики работают с ним через pull-request’ы. Для разных окружений используются либо разные ветки (например, `main` для продакшена, `develop` для тестирования) или тегированные релизы, но **базовая структура кода одна и та же**. Если появляется необходимость выделить общие компоненты (например, клиент для внешнего API, используемый несколькими сервисами), этот код выносится в библиотеку (NuGet пакет или общий репозиторий-библиотеку) и подключается через `PackageReference` в каждом сервисе, вместо копирования исходников.

**Подводные камни:**  
- Нельзя допускать, чтобы два разных приложения **делили один репозиторий**. Например, веб-сайт и отдельный скрипт импорта данных – это разные приложения, и им полагаются разные кодовые базы (если они не являются частями монолитного приложения).  
- Если репозиторий разрастается и содержит «слабосвязанные» части, стоит задуматься о разделении его на микросервисы или библиотеки. В монолитном репо, нарушающем принцип единой кодовой базы, сложно управлять версиями: какое состояние кода соответствует тому или иному развёртыванию? 12-факторное приложение избегает этой неопределённости, строго следуя принципу «one codebase – many deploys».

**Лучшие практики:** Используйте систему контроля версий (Git) и автоматизируйте развертывание прямо из репозитория. Например, настроить CI/CD, чтобы при пуше в `main` собирался и раскатывался новый релиз. Храните в репо **только код приложения** – никакого *машиноспецифического* конфигурационного файла, паролей или зависимостей, которые нельзя получить из декларации (об этом далее). Репозиторий является **единственным источником истины** для приложения – зная хеш коммита и соответствующую конфигурацию, вы всегда можете воспроизвести точно такую же версию приложения на любом окружении.

## II. Зависимости (Dependencies)

**Определение:** Все зависимости приложения должны быть **явно объявлены** в специальном манифесте, и приложение должно запускаться в **изолированном окружении**, где установлены только эти объявленные зависимости ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BD%D0%B5%20%D0%B4%D0%BE%D0%BB%D0%B6%D0%BD%D1%8B%20%D0%B8%D0%BC%D0%B5%D1%82%D1%8C%20%D0%BD%D0%B5%D1%8F%D0%B2%D0%BD%D1%8B%D1%85,%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0%20%C2%AB%D0%BD%D0%B5%20%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D1%87%D0%B8%D0%BB%D0%B0%D1%81%D1%8C%C2%BB%20%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9)). Нельзя полагаться на то, что на системе уже “по умолчанию” установлены нужные библиотеки. 

**Для чего это нужно:** Явное указание зависимостей гарантирует **повторяемость** запуска приложения в любом окружении. Если приложению нужен Newtonsoft.Json версии X или библиотека ImageMagick, то эти требования прописаны в зависимостях. Разработчик, клонировав репозиторий, может одним действием установить всё необходимое (в .NET – `dotnet restore` подтянет NuGet-пакеты). Изоляция зависимостей предотвращает конфликт версий и ситуацию, когда на одном сервере обновили библиотеку, и другое приложение неожиданно сломалось из-за несовместимости. 

В современных языках обычно есть менеджеры пакетов: например, **NuGet** для .NET, **npm** для Node.js, **Maven** для Java и т.д. ([Концепция Twelve-Factor App и Kubernetes / Хабр](https://habr.com/ru/companies/slurm/articles/785658/#:~:text=%D0%AF%D0%B2%D0%BD%D0%BE%20%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D1%8F%D0%B9%D1%82%D0%B5%20%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%B8,%D0%92%D0%BC%D0%B5%D1%81%D1%82%D0%BE%20%D1%8D%D1%82%D0%BE%D0%B3%D0%BE%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%BE%D0%BD%D0%B8%D1%80%D1%83%D0%B9%D1%82%D0%B5%20%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8E%2C%20%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D0%B0%D1%8F)). .NET Core/5+ проекты хранят зависимости в файле проекта `.csproj` (или отдельно `packages.config` в старых версиях). Все нужные пакеты перечислены там с указанием версий. При сборке или публикации проекта .NET, пакетный менеджер скачивает эти зависимости. **Изоляция** в .NET достигается тем, что каждая сборка включает свои копии необходимых DLL (в папке `bin` или внутри контейнера). В .NET Core **отсутствует GAC** (Global Assembly Cache) для пользовательских пакетов – это сделано в пользу принципа явных, локальных зависимостей.

**Docker-контейнеры** также играют важную роль: контейнер упаковывает не только библиотечные зависимости, но и зависимости на уровне ОС. Например, если приложению нужен специфичный образ ОС или системная библиотека (libssl, шрифты и т.п.), Docker-файл явно их устанавливает (через `RUN apt-get install ...` в образе). Таким образом, окружение выполнения становится предсказуемым и повторимым, а приложение не зависит от случайного софта на хосте ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%B8%D0%BB%D0%B8%20%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B5%D0%B5%20%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D1%82%D1%8C%20%D0%BD%D0%BE%D0%B2%D1%8B%D0%B5%20%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8)) ([Простыми словами о Twelve-Factor App / Хабр](https://habr.com/ru/articles/261171/#:~:text=%D0%A2%D1%83%D1%82%20%D1%81%D0%BB%D0%B5%D0%B4%D1%83%D0%B5%D1%82%20%D1%83%D0%BF%D0%BE%D0%BC%D1%8F%D0%BD%D1%83%D1%82%D1%8C%20Docker%2C%20%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9,%D1%8F%D0%B2%D0%BD%D0%BE%20%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%20%D0%B4%D0%B0%D0%B6%D0%B5%20%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D1%82%D0%B8%20%D0%9E%D0%A1)).

**Пример (ASP.NET Core):** В файле проекта ASP.NET Core (`MyApp.csproj`) явно указаны все NuGet-пакеты: например, `"Microsoft.EntityFrameworkCore.SqlServer"` версии 7.0.5 для работы с SQL Server, `"Serilog.AspNetCore"` версии 5.0.0 для логирования и т.д. Ни один из этих пакетов не предполагается «уже установленным» в системе – они подтягиваются при сборке. Допустим, приложение требует **Node.js** для сборки фронтенда – вместо зависимости на глобальный Node, можно использовать механизм *Node.js Tool Installer* в CI или запускать сборку фронта внутри контейнера Node. В Dockerfile для нашего приложения мы указываем базовый образ `mcr.microsoft.com/dotnet/aspnet:7.0` (содержит нужный .NET Runtime) и копируем внутрь результаты `dotnet publish` – тем самым у контейнера есть только те библиотеки, что мы явно включили.

**Антипаттерны/подводные камни:**  
- **Неявные зависимости:** Плохой пример – .NET приложение, требующее наличия .NET SDK или MS Office на сервере для каких-то функций, и не сообщающее об этом явно. Если развернуть такое приложение на чистый сервер или Linux-контейнер, оно сломается. Решение: либо включить зависимость в список (например, использовать библиотеку для обработки документов вместо COM-вызова к установленному MS Office), либо задокументировать и автоматизировать установку этой зависимости.  
- **Различия версий:** Если разработчик использует одну версию библиотеки, а на продакшене случайно присутствует другая (например, глобально установлен пакет), то поведение может отличаться. Изоляция (вплоть до контейнера) устраняет эту проблему – приложение всегда берёт «свои» версии библиотек.  
- **Коммит скомпилированных библиотек:** Хранить в репозитории сами бинарники зависимостей – плохая практика. Нужно хранить только манифест (список) и версии, а не сами пакеты. Исключение – собственные модули, которые не публикуются в пакетном виде, но и их лучше подключать через git-субмодули или приватные NuGet-фиды, а не копировать код напрямую.

**Best practices:** Всегда обновляйте манифест зависимостей при добавлении новой библиотеки (в .NET `dotnet add package` делает это автоматически). Проводите **восстановление зависимостей (restore)** в чистой среде (например, CI-сервер) при каждом билде, чтобы гарантировать, что список полон. Используйте **семантическое версионирование** и фиксируйте версии в разумных пределах (например, `"Serilog.AspNetCore": "5.0.*"` чтобы тянуть только патчи, а не мажорные обновления без проверки). Для системных зависимостей применяйте контейнеризацию: описывайте в Dockerfile все необходимые шаги (установить curl, установить LibreOffice и т.п.), чтобы новый разработчик или сервер мог просто собрать образ и получить полностью настроенное окружение.

## III. Конфигурация (Config)

**Определение:** Конфигурация – это **настройки, которые отличаются между развертываниями** (средами). Twelve-Factor рекомендует **хранить конфигурацию в переменных окружения** (environment variables), а не в коде приложения ([Обзор методологии “The 12-Factor Applications”](https://pryazhnikov.com/ru/12factor-apps/#:~:text=%D0%9A%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%28config%29%20,%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D1%85%20%D1%80%D0%B0%D0%B7%D0%B2%D1%91%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%D0%BD%D0%B8%D1%85%20%D0%B1%D0%B5%D0%B7%20%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BA%D0%BE%D0%B4%D0%B0)). К конфигурации относятся: строки подключения к БД, креденшлы к сервисам, адреса API, секретные ключи, параметры, зависящие от окружения и т.д. ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%9A%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%E2%80%94%20%D1%8D%D1%82%D0%BE%20%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%20%D1%81%D1%80%D0%B5%D0%B4%D1%8B,%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F)). 

При таком подходе **код приложения универсален для всех окружений**, а конкретные значения подставляются снаружи. Если вы можете выложить свой код в open-source без утечки секретов – значит, вы правильно отделили конфигурацию от кода ([Простыми словами о Twelve-Factor App / Хабр](https://habr.com/ru/articles/261171/#:~:text=%D0%9A%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%E2%80%94%20%D1%8D%D1%82%D0%BE%20%D0%B2%D1%81%D0%B5%20%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B%2C,%D0%BE%D1%82%20%D1%82%D0%BE%D0%B3%D0%BE%20%D0%B3%D0%B4%D0%B5%20%D0%B7%D0%B0%D0%BF%D1%83%D1%89%D0%B5%D0%BD%D0%BE%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5)).

**Почему это важно:** Разделение кода и конфигурации делает деплой **гибким и безопасным**. Вам не нужно менять код при переходе с тестовой базы данных на боевую – достаточно изменить переменную окружения `ConnectionString`. Секретные данные (пароли, ключи) не попадают в VCS, снижая риск компрометации. Кроме того, использование переменных окружения упрощает автоматизацию: скрипты деплоя или Docker Compose могут задавать переменные для каждого контейнера. Это лучше, чем поддерживать множество конфигурационных файлов для разных сред (dev, staging, prod) – число файлов растёт с числом сред и версий, их легко перепутать ([Простыми словами о Twelve-Factor App / Хабр](https://habr.com/ru/articles/261171/#:~:text=%D0%94%D0%BE%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D0%BE%20%D0%BF%D0%BE%D0%BF%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B9%20%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%20%E2%80%93%20%D1%8D%D1%82%D0%BE,%D0%BA%D0%BE%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE%20%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2%2C%20%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5%20%D0%BD%D0%B0%D0%B4%D0%BE%20%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%B8%D0%B2%D0%B0%D1%82%D1%8C)).

**Примеры (ASP.NET Core и Docker):**

- *В ASP.NET Core* система конфигурации по умолчанию умеет читать из переменных окружения. Например, если в `appsettings.json` задано `"ConnectionStrings": { "Default": "Server=.;Db=dev;User=dev;Pwd=dev;" }`, то для продакшена мы **не будем менять файл**, вместо этого установим переменную среды `ConnectionStrings__Default` (двойное подчеркивание `__` используется для вложенных настроек) со значением продакшен-строки подключения. При запуске ASP.NET Core в продакшене, эта переменная перекроет значение из JSON-файла ([Работа с конфигурацией в ASP.NET Core - Tproger](https://tproger.ru/articles/rabota-s-konfiguraciej-v-asp-net-core--prakticheskoe-rukovodstvo-s-nastrojkami-mongodb-251910#:~:text=ASP,json%29%2C%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%BE%D0%BA%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%B8%20%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%B5)). Таким образом, **один и тот же билд** приложения можно запускать в разных окружениях, передавая разные переменные. В коде доступ к конфигу выглядит одинаково: `Configuration["ConnectionStrings:Default"]` – не важно, откуда пришло значение (из JSON или из env var). 

- *Docker:* Переменные окружения особенно удобно передавать контейнерам. Например, в `Dockerfile` можно указать команду `ENV ASPNETCORE_ENVIRONMENT=Production`, а при запуске контейнера переопределить или добавить `-e ConnectionStrings__Default="Server=prod.db;..."`. Также, Docker Compose YAML позволяет задавать env для каждого сервиса. Это соответствует 12-фактор подходу. Кроме того, чувствительные данные можно хранить через механизмы Docker Secrets или переменные в Kubernetes, что вписывается в ту же модель – приложение всё равно получает их как переменные окружения.

**Антипаттерны:**

- **Хардкод и репозиторий:** Критически неправильно хранить пароли и ключи API прямо в коде (например, константой в C#) или даже в закрытом репозитории. Это затрудняет смену пароля и грозит утечкой (кто-то случайно сделает репозиторий публичным или просто больше людей получат доступ к секретам). 12-Factor требует, чтобы репозиторий можно было открыть, не раскрывая конфиденциального – **код не зависит от окружения, а конфигурация зависит от окружения** ([Простыми словами о Twelve-Factor App / Хабр](https://habr.com/ru/articles/261171/#:~:text=,%D0%90%D0%9F%D0%98)).

- **Конфигурационные файлы на каждую среду:** Иногда практикуют `appsettings.Development.json`, `appsettings.Production.json` и т.п. Это лучше, чем хардкод, но масштабируется плохо: если добавится новая среда (например, *staging* или *feature-branch*), придётся добавлять новый файл, поддерживать его актуальность. Легко запутаться, какой файл на каком окружении задействован. Переменные окружения же могут быть заданы гибко для любой комбинации (имя среды, версия, регион деплоя и т.д.) без изменения приложения.

- **Неочевидные настройки:** Бывает, что конфигурация определяется не явно, а, к примеру, через разницу в сборках. Например, разработчик собрал специальный “стенд” билд с другими настройками. Это противоречит разделению build/release (фактор V) и усложняет поддержку. Всё, что меняется между развертываниями, должно быть вынесено из этапа билда в этап конфигурации запуска.

**Практические советы:** Используйте стандартные механизмы .NET для работы с конфигурацией: `IConfiguration` в ASP.NET Core автоматически агрегирует JSON файлы, env vars, аргументы командной строки и др. В разработке удобно применять файл **`.env`** (перечисление VAR=VALUE) вместе с инструментами, чтобы загрузить переменные (Visual Studio Code + расширение *Dotenv*, либо `docker-compose` умеет читать .env файл). В продакшене же переменные задаются средой выполнения (в Azure это Application Settings, в Kubernetes – ConfigMap/Secret, в Windows – переменные системы). **Не злоупотребляйте количеством параметров** – формируйте их исходя из реальной потребности менять между окружениями. Например, connection string точно зависит от окружения, а вот параметр вроде “показывать ли капчу” – это бизнес-логика, она скорее должна быть фичей (и меняться через деплой нового кода). 

Для безопасного хранения секретных конфигов рассмотрите специальные хранилища (Azure Key Vault, Hashicorp Vault) – при запуске все равно вытаскивайте данные оттуда в переменные окружения приложения. Главное, чтобы **ни один секрет не просочился в репозиторий** и чтобы настройка окружения происходила вне приложения.

## IV. Сторонние сервисы (Backing Services)

**Определение:** Под *сторонними (вспомогательными) сервисами* понимаются любые сервисы, которые приложение потребляет по сети во время работы: базы данных, кеши, системы очередей, SMTP для отправки почты, внешние API и пр. ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=IV)). Принцип гласит: **не делайте различий между локальным и сторонним сервисом** – *все* ресурсы считаются подключаемыми, сменяемыми *без изменения кода*. Доступ к ним полностью определяется конфигурацией. Например, если вы используете PostgreSQL локально, а в облаке переходите на Amazon RDS, это не должно требовать правок в коде ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%B8)) ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%97%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0%20%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9%20%D0%B1%D0%B0%D0%B7%D1%8B%20%D0%BD%D0%B0%20Amazon,%D0%B4%D0%BE%D0%BB%D0%B6%D0%BD%D0%BE%20%D0%B2%D0%BB%D0%B8%D1%8F%D1%82%D1%8C%20%D0%BD%D0%B0%20%D0%BA%D0%BE%D0%B4%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F)).

**Что решает этот подход:** Он обеспечивает **гибкость и устойчивость** приложения к изменениям инфраструктуры. Приложению всё равно, к какому именно экземпляру базы подключаться – к локальной на порту 5432 или к кластеру в облаке – оно берёт строку подключения из переменной окружения и работает. Это позволяет легко переключаться на резервные сервисы, тестировать с фейковыми сервисами или масштабировать компоненты. Также такой дизайн поощряет использование *service binding* принципа: вместо жёсткого встраивания какого-то сервиса, мы всегда можем перенастроить приложение на альтернативный, если исходный недоступен.

**Пример (C# ASP.NET Core):** Рассмотрим приложение, которое использует кэш Redis для сессий и базу данных SQL Server для данных. В локальной разработке разработчик может поднять Docker-контейнеры **Redis** и **SQL Server Express**, а в продакшене используются Azure Cache for Redis и Azure SQL (управляемые сервисы). Благодаря фактору III (конфигурация), строки подключения заданы переменными `REDIS_CONNECTION` и `SQL_CONNSTR`. В коде же настроено что-то вроде:

```csharp
services.AddStackExchangeRedisCache(options => {
    options.Configuration = Configuration["REDIS_CONNECTION"];
});
services.AddDbContext<AppDbContext>(opt => {
    opt.UseSqlServer(Configuration["SQL_CONNSTR"]);
});
```

Заметим, код **не меняется** между окружениями. Он просто берёт значения из конфигурации. Если завтра решат перейти с SQL Server на PostgreSQL – разработчики изменят код (на другой провайдер EF Core), но после этого снова можно использовать принцип: локально Postgres в контейнере, в продакшене – Amazon RDS Postgres, строка подключения – через переменную, код – одинаковый.

**Ещё пример – сторонний API:** допустим, приложение интегрируется с геокодинг-сервисом. В тестовом окружении мы не хотим вызывать реальный API (платно или медленно), поэтому разворачиваем локальный мок-сервис. Достаточно изменить `GEOCODER_URL` переменную, и приложение начнёт стучаться на наш локальный сервис вместо боевого. Код при этом обращаться будет, скажем, через `HttpClient` к `Configuration["GEOCODER_URL"]`. Опять же, без условных операторов вида `if (Dev) use one URL else use other URL` – вся логика переключения вне приложения.

**Типичные ошибки:**  
- **Встроенные сервисы:** Противоположность принципу – когда, например, приложение *требует* локальной базы и не умеет читать строку подключения извне, или жёстко запрограммировано на конкретный SMTP-сервер. Бывали случаи, когда разработчики писали URL внешнего API прямо в код (нарушение фактора III и IV одновременно) – приложение негибко и привязано к одному сервису.  
- **Неразличение ролей сервисов:** Иногда разработчики пытаются *вшить* вспомогательный сервис внутрь приложения. К примеру, Embedded database (SQLite файл) вместо нормальной базы – это удобно для начального шага, но плохо масштабируется. 12-Factor предпочитает чётко разделять: приложение и его backing service. Лучше использовать полноценный сервис даже в дев-среде, либо иметь возможность легко перейти на него.

**Лучшие практики:** Тестируйте замену сервисов. Например, имейте скрипт миграции с локальной БД на облачную, чтобы убедиться, что код действительно абстрагирован. Держите информацию о подключении в одном месте (конфигурация), чтобы переключение было атомарным. Используйте именованные переменные окружения, отражающие роль, а не конкретную реализацию. К примеру, `PRIMARY_DB_URL` вместо `POSTGRES_URL` – тогда если смените Postgres на другой движок, название переменной можно оставить тем же (меняется только её значение). 

Также применяйте *health checks* (зондирование) внешних сервисов, но это уже больше про мониторинг: приложение может периодически логировать состояние подключения к внешнему сервису. Главное – код не должен «думать», локальный ресурс он дергает или облачный, он просто обращается по адресу/ключам из настроек.

## V. Сборка, релиз, запуск (Build, Release, Run)

**Определение:** Жизненный цикл развёртывания 12-факторного приложения разделён на три четких этапа ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%A0%D0%B0%D0%B7%D0%B2%D0%B5%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20%D1%81%D0%BE%D1%81%D1%82%D0%BE%D0%B8%D1%82%20%D0%B8%D0%B7%20%D1%82%D1%80%D0%B5%D1%85,%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D1%85%20%D1%8D%D1%82%D0%B0%D0%BF%D0%BE%D0%B2)):

1. **Сборка (Build):** преобразование исходного кода в исполняемый артефакт. Включает компиляцию, упаковку статических ресурсов, сборку бинарников, загрузку зависимостей – все шаги, после которых получается готовый *пакет приложения*. В .NET это, например, выполнение `dotnet publish`, создающее самодостаточную папку с DLL и прочими файлами. В мире Docker – это построение образа (`docker build`), где на выходе получается готовый контейнер с приложением.
2. **Релиз (Release):** объединение **сборки** с **конфигурацией** текущего окружения. На этом этапе в артефакт внедряются конкретные значения параметров для конкретного деплоя. В случае контейнера – по сути, когда вы запускаете контейнер с определённым набором переменных окружения, вы получаете релиз. Если без контейнеров, то релиз – это, например, взятый из CI архив с приложением + файл конфигурации для продакшена, объединённые вместе. Важно, что **каждый релиз имеет уникальный идентификатор** (например, номер сборки или git-хеш + номер окружения) и может быть при необходимости повторно запущен в точности. Релизы являются неизменяемыми – после создания релиза его нельзя «патчить»; любое изменение требует новой сборки и нового релиза.
3. **Запуск (Run):** собственно исполнение приложения в виде одного или нескольких процессов, используя релиз. Этот этап должен происходить максимально быстро и автоматически. В идеале, запуск – это простая команда (например, `docker run` или запуск исполняемого файла) без дополнительных ручных действий.

**Принцип:** Разработчик (или система CI) инициирует сборку, получая артефакт. Затем конфигурация (см. Фактор III) применяется для конкретной среды, и создаётся релиз. Запуск релиза – отдельный шаг, который можно повторять сколько нужно (например, перезапуск после сбоя, масштабирование – запуск нескольких экземпляров) без участия разработчика ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%9F%D1%80%D0%B8%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%2012%20%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%BE%D0%B2,%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D1%85%20%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA%2C%20%D0%B1%D0%B5%D0%B7%20%D0%B2%D0%BC%D0%B5%D1%88%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D1%82%D0%B2%D0%B0%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B0)). 

**Зачем это нужно:** Строгое разделение обеспечивает **предсказуемость и автоматизацию деплоя**. Если что-то пошло не так на этапе запуска, мы точно знаем, какой код (билд) и какие настройки (конфиг) использовались – то есть, какой релиз вызвал проблему. Мы можем оперативно откатиться на предыдущий успешный релиз (он у нас сохранён). Также это устраняет проблему «работает только если запускать из-под Visual Studio»: весь процесс стандартизован и не зависит от ручных шагов. В случае аварии можно автоматически поднять новый процесс того же релиза (например, оркестратор перезапускает контейнер) без необходимости переконфигурировать или пересобирать на лету.

**Пример (CI/CD .NET):** Представим, что код находится на GitHub. Настроен GitHub Actions (или Azure DevOps Pipeline), который выполняет:  
- **Build:** шаги: `dotnet restore`, `dotnet build --configuration Release`, `dotnet publish -c Release -o publish`. Затем `docker build -t myapp:build123 .` – сборка Docker-образа с тегом, включающая результаты publish.  
- **Release:** после успешной сборки, pipeline берёт полученный образ `myapp:build123`, логирует его в регистри (например, Docker Hub или Azure Container Registry) под версией `1.2.3` (соответствующей этому релизу). Конфигурация (например, connection strings, секреты) хранится отдельно – в Kubernetes YAML или в настройках хостинга. Развертывая релиз, Operations/DevOps-инженер или автоматический скрипт создаёт запись о новом релизе (например, Helm release в Kubernetes, или новая версия deployment), указывая образ `myapp:1.2.3` и нужные env vars.  
- **Run:** Kubernetes запускает контейнеры из образа `myapp:1.2.3`, передавая им через переменные окружения конфигурацию. Эти контейнеры – запущенные процессы приложения. Если нужно масштабировать, можно запустить ещё несколько контейнеров этого же релиза. Если обнаружен дефект, можно остановить новый релиз и развернуть предыдущий (образ `1.2.2`), не перекомпилируя ничего.

Обратите внимание: сборка (компиляция .NET) происходила в CI, а не на продакшене. Релиз идентифицируется версией/номером. Запуски могут быть множественными и автоматическими.

**Подводные камни и нарушения:**  
- **Изменение кода на проде:** Категорически не рекомендуется править что-либо на уже собранном артефакте. Например, «подправить файл конфигурации внутри контейнера и перезапустить» – это создаёт неофициальный релиз, который неповторим. Любые изменения -> новая сборка -> новый релиз.  
- **Смешивание этапов:** Бывает, что сборка пытается зависеть от параметров окружения (например, скрипт сборки вставляет текущую дату или имя сервера в код). Это делает сборки неприменимыми в других условиях. Сборка должна быть универсальна и безконфигурационна. Наоборот, запуск не должен выполнять компиляцию. Если при каждом старте контейнера он сначала компилирует что-то – это нарушение.  
- **Ручной запуск без учета версий:** Например, копирование файлов по FTP на сервер мимо системы версионирования – такие развертывания сложно отследить и воспроизвести. Лучше автоматизировать, чтобы каждый деплой регистрировался как релиз с номером.  
- **Долгий/сложный запуск:** Если для запуска требуются многочисленные ручные действия (нажать кнопку в панели, очистить кэш вручную, запустить SQL-скрипт), то велика вероятность ошибки. Стремитесь, чтобы запуск был **атомарной операцией** – ideally, одной командой или через оркестратор, который сам всё делает. Дополнительные действия (миграции, прогрев кэша) должны быть либо встроены в код (в разумных пределах), либо оформлены как отдельные админ-процессы (фактор XII).

**Практики:** Документируйте и автоматизируйте pipeline: **Continuous Integration / Continuous Deployment (CI/CD)** – естественный спутник 12-Factor. Используйте системные идентификаторы для релизов (номера версий, git commit SHA). Храните артефакты сборки (например, Docker образы или zip-файлы) в репозитории артефактов – это позволит поднять старую версию при необходимости. Проверяйте, что восстановление системы можно сделать развернув последний стабильный релиз, без повторной компиляции (т.к. исходный код мог уже уйти далеко вперёд). 

Также отслеживайте отличие между релизами – в сложных системах бывает полезно иметь **Changelog** между версиями, чтобы знать, что поменялось. Но кодовая база с VCS и тегами уже содержит эту информацию.

## VI. Процессы (Processes)

**Определение:** 12-факторное приложение запускается в одном или нескольких **процессах**, не хранящих долговременное состояние на локальном уровне ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B4%D0%BE%D0%BB%D0%B6%D0%BD%D0%BE%20%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA%D0%B0%D1%82%D1%8C%20%D0%BA%D0%B0%D0%BA%20%D0%BE%D0%B4%D0%B8%D0%BD,%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D0%B5%D0%BC%D0%BE%D0%BC%20%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D0%B5)). Каждый процесс – это активный экземпляр приложения (например, запущенный `.exe` или контейнер). Они могут обрабатывать запросы, выполнять фоновые задачи и т.п. Важно, что сами процессы **stateless**: никакие данные, которые нужно сохранить между запуском процессов или между разными запросами, не хранятся внутри процесса – вместо этого всё в выносится во внешние хранилища.

**Почему:** Такой подход делает приложения **масштабируемыми и отказоустойчивыми**. Если процесс умер, он не унес с собой важные данные – их можно прочитать заново из БД при запуске нового процесса. Если надо запустить второй процесс (для баланса нагрузки), он не требует “специального состояния” – он идентичен первому и готов обслуживать запросы сразу после запуска. В традиционных приложениях часто бывает, что в памяти процесса хранятся пользовательские сессии, кэши, файлы и т.д. – это затрудняет масштабирование (появляется идея «липких сессий» для одного сервера) и восстановление (падение сервера ведёт к потере сессий). 12-факторный процесс таких проблем избегает.

**Примеры:**

- *ASP.NET Core веб-сервер:* По умолчанию, веб-приложение на Kestrel не сохраняет состояние между запросами – каждый HTTP запрос обрабатывается независимо. Однако разработчики могут добавить, например, **Session** с хранением в памяти (`services.AddDistributedMemoryCache()` + `AddSession()`). Если использовать встроенный InMemory-кэш для сессий, то при масштабировании на 2+ процесса сессии начнут теряться (пользователь, пришедший на другой экземпляр, не найдёт своей сессии). Правильное решение – использовать распределённое хранилище сессий (например, Redis через `AddStackExchangeRedisCache`), то есть вынести сессионные данные за пределы процессов. Тогда все экземпляры приложения могут доступиться к общему состоянию. 

- *Файловое хранение:* Предположим, приложение позволяет пользователям загружать аватарки. Некорректно будет сохранять их прямо в локальную файловую систему (например, в папку `wwwroot/uploads`) – если приложение перезапустится в новом контейнере или запущено несколько экземпляров, другие экземпляры не увидят файл. 12-Factor предлагает хранить такие данные во внешнем хранилище: напр., в облачном объектном хранилище (AWS S3, Azure Blob Storage) или общем сетевом диске. Локально при разработке можно эмулировать это, но суть – **не полагаться на локальный диск процесса** для долговременных файлов. В .NET можно, например, сразу сохранять стрим в Azure Blob SDK, минуя сохранение на диск.

- *Кэш и очередь:* Вместо использования memory cache, лучше использовать распределенный кэш. Вместо `ConcurrentQueue` в static-переменной для межзапросной очереди – использовать внешний брокер (Azure Service Bus, RabbitMQ). Тогда при разбиении приложения на несколько процессов, они смогут совместно пользоваться кэшем/очередью.

**Статус данных в процессе:** Допустимо использовать локальную память или диск *внутри процесса* **только как временное буферизированное хранилище** (например, для сортировки данных, обработки изображения и т.д.), но финальный результат должен сохраняться вне процесса ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B4%D0%BE%D0%BB%D0%B6%D0%BD%D0%BE%20%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA%D0%B0%D1%82%D1%8C%20%D0%BA%D0%B0%D0%BA%20%D0%BE%D0%B4%D0%B8%D0%BD,%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D0%B5%D0%BC%D0%BE%D0%BC%20%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D0%B5)). Резюмируя: **процессы – без состояния**, а **состояние – во внешних сервисах**.

**Дополнительный аспект – **Share Nothing Architecture****: 12-факторные приложения следуют принципу «не делиться» – процессы не делят между собой ничего напрямую. Если нужно скоординировать что-то между процессами, используют внешние координаторы (БД, распределённые блокировки, etc.), но не, скажем, общую память (что и невозможно между контейнерами).

**Антипаттерны:**  
- **Sticky Session / Stateful Server:** Это термин из веб-инфраструктуры, когда конкретный пользователь всегда направляется на тот же сервер, потому что только там есть его данные (сессия). Это ломает принцип interchangeability процессов. Случись что с тем сервером – пользователь потеряет данные. 12-factor предпочитает хранить сессию вне (например, сервер может идентифицировать пользователя по токену JWT, а данные сессии не хранить вообще, либо хранить в Redis доступном всем).  
- **Singletons с состоянием:** В .NET можно иметь `static` объекты, которые будут жить все время жизни процесса. Если там копится состояние – это проблемно. Например, static-список последних подключений. При нескольких процессах каждый будет иметь свой список, и полной картины не будет. Лучше использовать внешнее хранилище для такого глобального состояния. (Static без состояния – например, static-утилиты – это нормально).  
- **Неочевидное состояние:** Иногда состояние может скрываться – например, пишете вы логи в файл (нарушение фактора XI) и предполагаете, что разные процессы пишут в один общий файл на диске – но если это контейнеры, у каждого свой файловый namespace, и логи тоже разделятся. Поэтому даже такие вещи нужно учитывать: проще не пытаться делить ресурс, а писать каждый в свой stdout.

**Best practices:** Проектируя .NET приложения, избегайте зависеть от локального `HttpContext` или `MemoryCache` для данных, живущих дольше запроса. Если нужен кэш между запросами – сразу закладывайте распределённый. Для файлов используйте абстракции (интерфейсы), которые можно реализовать через локальную файловую систему для отладки, а в продакшене – через облачное хранилище. Например, интерфейс `IFileStorageService` с методами `SaveFileAsync`, `GetFileAsync` – локально он пишет в папку, в облаке – в Azure Blob. Код приложения не меняется при этом, а процессы остаются stateless относительно друг друга.

При масштабировании убедитесь, что **новый процесс может стартовать и начать обслуживать запросы с нуля**, не нуждаясь в «прогреве» состояния. Если прогрев всё же нужен (например, заполнить кэш при старте), то при статeless архитектуре это не разрушит правильность, просто первое время ответы могут быть медленнее, но функционально всё корректно.

## VII. Привязка портов (Port binding)

**Определение:** 12-факторное приложение **само экспонирует веб-сервис** через порт, не полагаясь на присутствие внешнего контейнера веб-сервера ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BD%D0%B5%20%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D1%82%20%D0%BE%D1%82%20%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B0)). Приложение как бы говорит: «я слушаю на таком-то порту, и принимаю запросы». Например, запуск Node.js-приложения, которое слушает `:3000` – классический пример. В контексте .NET исторически приложения работали под управлением IIS. Но ASP.NET Core нарушил эту традицию: теперь даже веб-приложение – это просто консольное приложение, запускающее **Kestrel**-сервер внутри себя.

**Зачем:** Это повышает **портативность и унификацию**. Приложение не зависит от конкретного хостинга. В Dev-режиме вы запускаете его локально – оно слушает http://localhost:5000. В Docker – оно слушает на контейнерном интерфейсе, а Docker пробрасывает на хост. В Kubernetes – схожая ситуация. Нет ситуации, что приложение может работать *только* под IIS/Apache – т.е. нет привязки к инфраструктуре. 12-факторное приложение можно поместить в любой окружение, где есть возможность открыть порт (будь то VM, контейнер, PaaS) – и оно начнет принимать запросы.

**ASP.NET Core пример:** При создании проекта по шаблону, в `Program.cs` обычно есть строка: `builder.WebHost.UseUrls("http://0.0.0.0:5000")` или определяется через `ASPNETCORE_URLS` переменную. Это и есть привязка к порту. По умолчанию Kestrel слушает 5000 (HTTP) и 5001 (HTTPS) в дев-режиме. При публикации в контейнер, мы можем настроить, например, `ENV ASPNETCORE_URLS=http://+:80` в Dockerfile, чтобы в контейнере приложение сразу слушало порт 80. Затем, при запуске `docker run -p 8080:80`, внешний порт 8080 хоста будет маппиться внутрь на 80, где сидит наше приложение. Все эти конфигурации происходят без изменения кода контроллеров или логики – мы лишь указываем, на каком адресе/порту крутиться.

**Конкретно про Windows и IIS:** В .NET Framework старого образца веб-приложение часто хостилось в IIS, а исполняемый `.exe` напрямую не умел обслуживать HTTP (это была библиотека .dll, загружаемая в рабочий процесс IIS). Это нарушало принцип port binding (приложение зависело от внешнего веб-сервера). В .NET Core разработчики исправили это – теперь каждая веб-служба содержит встроенный сервер. Если всё же используется IIS/Azure Web App в качестве реверс-прокси, приложение всё равно **само должно уметь обслуживать** – IIS только проксирует к нему. В терминах 12-Factor, **IIS не является частью приложения**, а лишь средством доставки трафика. Поэтому приложение должно быть проверено, что оно способно работать и вне IIS (например, запуском `dotnet MyApp.dll`).

**Неприменимость принципа:** Есть тип программ, которые не предоставляют сетевой сервис (например, batch-утилита). Для них port binding не имеет смысла напрямую. Но косвенно – даже такие приложения могут предоставлять результаты работы через stdout (как поток), который можно воспринимать аналогично сервису. Однако для веб/бизнес приложений, как правило, мы говорим именно о веб-сервисах на порту.

**Подводные камни:**  
- **Использование фиксированных портов, конфликтов:** Если ваш микросервис *жёстко* слушает 5000 порт и это не меняется, в среде, где на одном хосте несколько сервисов, будет конфликт. Лучше делать порт настраиваемым через конфиг (например, `PORT` env var) и поддерживать параметризацию. Многие PaaS (Heroku, Azure) сами задают порт приложению через переменную (`PORT=<number>`), а ваша задача – прочитать её и слушать на ней. Kestrel, например, может быть настроен подставлять порт из переменной.  
- **HTTPS сертификаты:** Когда приложение само слушает порт, оно может также заниматься TLS. В продакшене зачастую TLS заканчивается на балансировщике, а до приложения идёт HTTP. Но если ваше приложение слушает TLS, вам нужно управлять сертификатами (напрямую или через конфиг). В Docker удобно монтировать сертификат и задавать `ASPNETCORE_Kestrel__Certificates__Default__Password` и `Path`. Главное – помнить, что за это отвечает само приложение.  
- **Обратные прокси:** В сценариях, когда всё же есть nginx/traefik как входная точка, не забывайте настроить Forwarded Headers middleware в ASP.NET Core, чтобы корректно обрабатывать схемы и IP. Это не столько про port binding, сколько общий нюанс самохостинга за прокси.

**Практики:** Проверяйте, что приложение может запускаться *самостоятельно*. Например, локально выполняйте `dotnet run` и обращайтесь к нему на указанном порту – оно должно работать без Visual Studio. В Docker, как часть CI, пишите тест, что контейнер успешно стартует и отвечает на запрос. Используйте переменные для управления портом, например, сделайте поддержку переменной `PORT` или `ASPNETCORE_URLS`. В Kubernetes манифесте указывайте containerPort, но сам контейнер должен внутри знать, какой порт слушать. 

Если делаете небанальный протокол (скажем, SignalR или gRPC), учтите, что всё равно binding остаётся – SignalR пойдёт поверх HTTP порта, а gRPC – тоже над HTTP/2 портом. Принцип тот же: **ваше приложение – это веб-сервер, а не просто библиотека**.

## VIII. Параллелизм (Concurrency)

**Определение:** 12-factor предлагает масштабировать систему **горизонтально, запуская дополнительные процессы**, а не усложняя один монолитный процесс. Разные типы работ выносятся в разные процессы, которые можно масштабировать независимо ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%9C%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%20%D1%81%20%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E%20%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2)). Это ещё называют *process model concurrency* – конкуренция через модель процессов.

**Пояснение:** Представим, наше приложение выполняет две основные функции: обслуживает веб-запросы пользователей и обрабатывает фоновые задачи (например, генерация отчетов по очереди). По 12-факторному стилю, мы разделим это на два процесса: **web-процесс** и **worker-процесс**. Они могут быть даже построены из одного и того же кода (например, запуск с разными аргументами), либо это два разных приложения в одном репо. Главное, что они разделены. Тогда под нагрузкой мы можем масштабировать **веб-процессы** (запустить, скажем, 5 экземпляров web) отдельно от воркеров (например, 2 экземпляра background worker). Каждая категория процессов масштабируется до требуемого уровня параллелизма без влияния друг на друга ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%BE%D0%B9%20%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D1%85%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%20%D0%B4%D0%BE%D0%BB%D0%B6%D0%BD%D1%8B%20%D0%B7%D0%B0%D0%BD%D0%B8%D0%BC%D0%B0%D1%82%D1%8C%D1%81%D1%8F,%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE%20%D1%82%D0%B5%20%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B%2C%20%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5%20%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D0%BE)).

**В .NET контексте:** Можно реализовать такой подход разными способами:
- Проще всего – **запустить несколько экземпляров приложения** для масштабирования. Например, в Docker/K8s просто задать реплик=5. Если приложение stateless (фактор VI), то 5 экземпляров спокойно разделят нагрузку (балансировщик раскидывает запросы).
- Если нужны разные типы процессов (web vs worker), можно разделить кодовую базу на два запускаемых проекта: `MyApp.Web.dll` и `MyApp.Worker.dll` внутри решения. Web – запускает Kestrel и обрабатывает HTTP, Worker – просто крутится, читает из очереди и обрабатывает задачи. Оба используют общий код (модели, сервисы) из библиотек. На проде можно их запустить в разных контейнерах/службах. Это полноценное микросервисное разделение внутри одного репозитория (если так удобно).
- Другой вариант – *одно приложение, разные режимы*. Например, приложение может иметь параметр запуска `--worker` и в `Program.cs` что-то вроде:
  ```csharp
  if (args.Contains("--worker")) { 
      // run background worker loop 
  } else {
      // run Kestrel web host 
  }
  ```
  Тогда, развертывая, мы можем запустить одни контейнеры с параметром `--worker`, другие без. По сути, получим тот же результат: отдельные процессы под разные задачи.

**Concurrency vs. parallel threads:** В .NET мы привыкли к многопоточности, async/await – это тоже форма конкуренции, но **внутри одного процесса**. 12-factor не запрещает использовать многопоточность (ваш веб-сервер, конечно, обслуживает параллельно запросы на потоках), но на уровне **масштабирования** упор делается на процессы. Модель проста: если не справляемся – добавь процесс. Не надо пытаться, к примеру, запускать 1000 асинхронных заданий в одном процессе, которые могут блокировать друг друга, лучше 10 процессов по 100 – надежнее, изолированнее, управляемее. 

**Пример (очереди задач):** В ASP.NET Core нельзя выполнять долгоживущие тяжелые задачи прямо в HTTP-запросе – принято ставить их во внешнюю очередь и обрабатывать асинхронно. Реализуем это по 12-факторному: веб-процесс получает запрос "генерировать отчет", кладёт задачу в очередь (например, Azure Queue или RabbitMQ) и сразу отвечает "принято". Worker-процесс (отдельно запущенный) мониторит очередь, берёт задачу и генерирует отчет. Если таких задач стало много, можно увеличить число воркер-процессов. Они будут параллельно брать разные задачи из очереди. В итоге система масштабируется не за счет сложных потоков внутри, а за счет **копий процесса**.

**Подводные камни:**  
- **Слишком много responsibility в одном процессе:** Если ваш единственный процесс делает и то, и другое, масштабирование усложняется. Например, вы запустили второй экземпляр приложения – он дублирует и веб и воркер. Возможно, веб-часть не нужна во втором так же, как первая, и наоборот. Лучше явно разделить.  
- **Гонка за масштабом без координации:** Если запускается несколько процессов, которые работают с одним ресурсом, убедитесь, что они корректно распараллеливаются. Например, два воркера берут задачу из очереди – нужно, чтобы задача не выполнялась дважды (обычно брокер сам гарантирует "одно сообщение – одному консьюмеру"). Но если использовать, допустим, SQL как очередь (получая первые не занятые записи) – параллелизм может привести к двойной обработке. Решение: *добавить координацию или перейти на правильный инструмент очереди*.  
- **Ограничения по ресурсам:** Запуская множество процессов, следите за ресурсами машины. Иногда вертикальное масштабирование (больше CPU/RAM) тоже имеет место, но 12-фактор концентрируется на горизонтальном. Например, если у вас 1 процесс вывозит 100 req/s на 1 ядре, а вам надо 1000 req/s, можно поднять 10 процессов на 2 ядрах (если они лёгкие) или на 10 ядрах. Как только 1 процесс перестаёт масштабироваться (уперся в CPU), вы решаете это добавлением процессов, а не меняя сам процесс.  
- **Daemonization:** 12-Factor советует, чтобы процессы **не демонизировались сами** ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%92%D0%B0%D0%B6%D0%BD%D0%BE%2C%20%D1%87%D1%82%D0%BE%20%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B%20%D0%BD%D0%B5%20%D0%B4%D0%BE%D0%BB%D0%B6%D0%BD%D1%8B,%D0%BD%D0%B0%20%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B8%20%D0%B8%20%D0%BF%D0%B0%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0)). Это значит, не надо запускать `ServiceHost.RunAsService()` внутри себя – пусть управление процессами (запуск, перезапуск при падении) делает внешний менеджер (система, Docker, k8s). В .NET Core консольное приложение по умолчанию ведёт себя правильно – не forkit в фон, а работает на переднем плане.

**Практики:** Проектируя систему, разложите её на типы процессов. Классический набор: *web*, *worker*, возможно *scheduler* (если нужен отдельный процесс для плановых задач). В Azure, например, можно использовать один App Service для веба, плюс фоновые WebJob’ы для задач. В Kubernetes – Deployment для веб, Deployment для воркера. Это следует тому же принципу.

Используйте возможности оркестрации: **автоматическое масштабирование** (autoscaling) хорошо работает, когда процессы независимы и не держат состояние (то есть соответствуют 12 фактору). K8s может по метрикам CPU поднять больше pod’ов – приложение это переживает без проблем. 

В самих процессах помните: не нужно кодировать логику “сколько у меня экземпляров запущено” – в идеале, каждому процессу все равно, он просто делает свою работу. Если нужен coordination (например, один из процессов должен периодически чистить кэш, а 10 других нет), лучше вынести этот функционал в отдельный маленький процесс (admin task по крону, см. фактор XII) или решить алгоритмически (напр., с помощью распределённого замка, чтобы ровно один из 10 выполнял задачу).

## IX. Утилизируемость (Disposability)

**Определение:** Максимизируйте надежность приложения за счёт **быстрого запуска** и **корректного завершения** процессов ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%91%D1%8B%D1%81%D1%82%D1%80%D1%8B%D0%B9%20%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA%20%D0%B8%20%D0%BA%D0%BE%D1%80%D1%80%D0%B5%D0%BA%D1%82%D0%BD%D0%BE%D0%B5%20%D0%B7%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B5%D0%BD%D0%B8%D0%B5)). “Утилизируемость” здесь означает, что процесс можно легко «утилизировать» – перезапустить или выключить – без негативных последствий. 

Ключевые аспекты:
- **Время запуска:** Процесс должен стартовать *как можно быстрее*. Идеал – секунды. Быстрый старт позволяет гибко выпускать новые релизы (минимизируя downtime), а также **масштабироваться под нагрузку** – оркестратор может быстро поднять дополнительные экземпляры приложения при наплыве трафика. Если запуск долгий (минуты), система менее отзывчива к изменению нагрузки и деплой может вызывать более длительные перебои.
- **Корректное завершение (graceful shutdown):** Когда приходит сигнал завершения (например, SIGTERM от Docker/K8s при остановке контейнера), приложение должно аккуратно завершиться: перестать принимать новые запросы, доделать текущие операции, освободить ресурсы (закрыть файлы, соединения к БД) ([Обзор методологии “The 12-Factor Applications”](https://pryazhnikov.com/ru/12factor-apps/#:~:text=%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%B4%D0%BE%D0%BB%D0%B6%D0%BD%D1%8B%20%D0%B7%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B0%D1%82%D1%8C%D1%81%D1%8F%20%D0%BA%D0%BE%D1%80%D1%80%D0%B5%D0%BA%D1%82%D0%BD%D0%BE,%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%B8%20%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%BC%20%D0%BD%D0%B5%D0%BE%D0%B6%D0%B8%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC%20%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0%D0%BC)). Это предотвращает потерю данных и обеспечивает корректность. Например, если воркер обрабатывает задачу, он должен либо завершить её быстро, либо вернуть задачу обратно в очередь перед выходом ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%AD%D1%82%D0%BE%20%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%81%D0%BB%D0%B5%D0%B4%D1%81%D1%82%D0%B2%D0%B8%D0%B5%20%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2%2C%20%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5,%D0%B7%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B0%D1%8E%D1%82%20%D1%81%D0%B2%D0%BE%D1%8E%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%83%2C%20%D0%B4%D0%B0%D0%B6%D0%B5%20%D0%B0%D0%B2%D0%B0%D1%80%D0%B8%D0%B9%D0%BD%D0%BE)).
- **Толерантность к сбоям:** Если процесс убит внезапно (SIGKILL, crash), система в целом должна устойчиво это перенести. Это достигается за счёт факторов VI (нет состояния внутри – нечего потерять) и VIII (есть другие процессы/воркеры, подхватят работу). Тем не менее, желательно минимизировать неожиданные падения – но если уж случились, они не должны корраптить систему.

**Применение в .NET:**

- *Быстрый старт:* ASP.NET Core приложения обычно стартуют за считанные секунды, особенно если не делают тяжёлой работы в `Program.Main`. Нужно следить, чтобы в `Startup` (или аналогичном инициализационном коде) не было долгих блокирующих операций. Например, инициализация DI-контейнера, небольшое чтение конфигов – ок. Но если приложение при старте генерирует 100k записей БД или прогревает кеш гигабайтами данных – это плохо. Такие вещи лучше вынести во внешние процессы (инициализация данных – админ задача) или делать лениво, по мере поступления запросов. 

  .NET компиляция JIT может дать небольшую задержку при первом запуске методов, но это, как правило, не критично. Можно рассмотреть использование **ReadyToRun** или **Tiered compilation** настроек, но это детали оптимизации. Главное – не задерживать старт искусственно.  
  Ещё пример: подсоединение к БД при старте. Если БД долго отвечает, приложение может тормозить запуск. Решение – возможно, делать такие коннекты асинхронно или с таймаутом/ретраями, чтобы не блокировать полностью запуск сервера. Kubernetes здоровьячки, кстати, помогут – можно пометить pod как готовым только когда действительно готов, но лучше делать приложение готовым скорее.

- *Graceful shutdown:* В ASP.NET Core есть механизм через `IHostApplicationLifetime` (в .NET 6+ это `IHostApplicationLifetime` доступен через DI, events ApplicationStopping/Stopped). Можно подписаться на событие `ApplicationStopping`, которое вызывается при SIGTERM. Например, если у вас есть фоновой сервис (HostedService) обрабатывающий задачи, он должен прекратить брать новые задачи и аккуратно завершить текущую. К cancellation tokens, которые .NET пробрасывает (например, в `ExecuteAsync` метод HostedService приходит `CancellationToken` реагирующий на стоп), нужно отнестись серьезно: проверять токен и выходить из циклов когда запрошено. 

  Для веб-запросов Kestrel автоматически делает grace period: при SIGTERM он перестаёт принимать новые подключения и ждёт некоторое время, пока завершатся текущие запросы, прежде чем принудительно оборвать. Вы можете настроить время ожидания через `HostOptions.ShutdownTimeout`. 

  **Важно:** Никогда не игнорируйте `TaskCanceledException` или `OperationCanceledException` как просто ошибки – они могут означать сигнал остановки. Ваш код должен быть написан так, чтобы *быть прерываемым*. Например, если у вас длинный вычислительный цикл, проверяйте токен отмены вручную внутри. Если работаете с очередями, при отмене - возвращайте невыполненные сообщения обратно. 

- *Restartability:* Если приложение упало, следующим шагом обычно будет перезапуск (Docker сделает, Kubernetes тоже). Поэтому, после незапланированного падения, новый процесс должен **начать с чистого листа** и не предполагать, что "вот там остался файл от прошлого запуска". Поскольку 12-factor исключает хранение локального состояния, вам и не нужно ничего такого делать. Тем не менее, обращайте внимание, что ваши транзакции либо атомарно завершились, либо откатились. Например, если приложение упало в середине обработки платежа – хорошо, если система спроектирована так, что либо платеж завершился, либо не начался вовсе, но не завис в полупроведённом состоянии. Это достигается использованием транзакций в БД, подтверждений в очередях *после* фактической обработки (ACK/NACK). 

**Антипаттерны:**  
- **Долгая инициализация:** Например, сервис запускается 2 минуты, потому что подгружает огромный ML-модель в память. Это ухудшает способность масштабироваться под нагрузку (auto-scaler не сможет быстро запустить доп. экземпляры). Если модель действительно нужна, возможно вынести её в отдельный сервис, который загружается заранее, а этот сервис вызывать по запросу. Или загружать её по требованию (lazy) хотя бы.  
- **Отсутствие обработки SIGTERM:** Если не сделать никаких настроек, Docker отправит SIGTERM и через ~30 секунд SIGKILL. Если ваше приложение игнорирует SIGTERM и продолжает работать, через 30с его убьют, возможно, на середине операции. Лучше перехватывать сигнал. В .NET Docker alpine образе, кстати, раньше был баг, что SIGTERM не ловился правильно – нужно убедиться, что используете образ, где это исправлено (в современных мср.майкрософт образах всё ок). 
- **Неочищенные ресурсы:** Если приложение не закрывает соединения к БД, то при массовом перезапуске можете получить утечки (БД может достичь лимита соединений). Хотя .NET при выгрузке процесса ОС освободит ресурсы, но корретное закрытие по логике полезно, например, для записей логов "сервер остановлен". 

**Практики:** Тестируйте остановку приложения. Запустите локально, потом сделайте Ctrl+C – наблюдайте, все ли части корректно остановились. В логах ASP.NET Core вы обычно увидите "Application is shutting down..." сообщение. Если у вас фоновые задачи, логируйте, когда они получают Cancel и останавливаются. Также тестируйте **быстрый перезапуск**: запустите контейнер, сразу остановите, снова запустите – должно работать каждый раз одинаково. 

Используйте **Orchestration features**: в Kubernetes задавайте `livenessProbe` и `readinessProbe`. Readiness probe позволит не слать трафик на под, пока он не поднялся полностью (помогает скрыть медленный старт, если он всё-таки есть). Liveness probe перезапустит контейнер, если он завис – это на случай, если вы где-то не учли graceful shutdown и приложение стало некорректно работать. Но лучше не доводить до такого – пиши код так, чтобы не вис и реагировал на cancel.

В логике приложения учитывайте сценарий, что выполнение может прерваться. Это особенно верно для систем с очередями и повторной обработкой: **должна быть идемпотентность или контроль транзакций**, чтобы повторный запуск процесса не привёл к дублированию результатов (например, не отправил повторно одно и то же письмо пользователю). Это уже вопрос архитектуры, но тесно связанный с 12 фактором – одноразовые, легко перезапускаемые процессы предполагают, что *повторный запуск сделает либо то же самое, либо безопасно подхватит работу с места остановки*. 

## X. Паритет окружений (Dev/Prod Parity)

**Определение:** Уменьшайте расхождения между **средой разработки** и **боевой средой**, а также **ускоряйте переход** кода из dev в prod ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%A1%D0%B5%D0%B9%D1%87%D0%B0%D1%81%20%D0%BC%D0%B5%D0%B6%D0%B4%D1%83%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%BE%D0%B9%20%D0%B8%20%D1%80%D0%B0%D0%B7%D0%B2%D0%B5%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%D0%BC,%D0%B8%20%D1%80%D0%B0%D0%B7%D0%B2%D0%B5%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%B0%D0%BA%20%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%20%D0%B1%D0%BB%D0%B8%D0%B6%D0%B5)). Идея в том, чтобы отличие между тем, что видит разработчик на своём компьютере, и тем, что происходит в продакшене, было минимальным по трем осям: **время, персонал, инструменты** ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%D0%B4%D0%BE%20%D1%81%D1%82%D0%B0%D1%80%D0%B0%D1%82%D1%8C%D1%81%D1%8F%20%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D1%83,%D0%B8%20%D1%80%D0%B0%D0%B7%D0%B2%D0%B5%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%B0%D0%BA%20%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%20%D0%B1%D0%BB%D0%B8%D0%B6%D0%B5)).

- **Время:** Код, написанный разработчиком, должен попадать в продакшен *через считанные часы* после написания ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=,%D1%81%D1%82%D0%BE%D1%80%D0%BE%D0%BD%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BB%D1%83%D0%B6%D0%B1%D1%8B%2C%20%D0%9E%D0%A1)). Это подразумевает частые релизы, непрерывную интеграцию. Чем меньше задержка, тем меньше вероятность, что окружения разойдутся (например, пока фича доезжает месяцами, окружение продакшена уже изменилось, вышли новые версии сервисов и т.д.).
- **Персонал:** Разработчики должны участвовать в деплое и наблюдать за работой своего кода в продакшене ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=,%D1%81%D1%82%D0%BE%D1%80%D0%BE%D0%BD%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BB%D1%83%D0%B6%D0%B1%D1%8B%2C%20%D0%9E%D0%A1)). Это ломает традиционную стену между Dev и Ops: DevOps-культура. Когда одни пишут, а другие сопровождают, часто обнаруживается разрыв – разработчик не знает, как его код ведёт себя “в живую”. По 12-фактору, тот же человек (или команда) ответственна и за написание, и за выкатывание, и за реакцию на проблемы. Это повышает качество: дев видит реальные проблемы и учитывает их сразу.
- **Инструменты:** Среда разработки должна быть максимально приближена к продакшену по используемым технологиям ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=,%D1%81%D1%82%D0%BE%D1%80%D0%BE%D0%BD%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BB%D1%83%D0%B6%D0%B1%D1%8B%2C%20%D0%9E%D0%A1)). Если в проде приложение крутится в Linux-контейнере с PostgreSQL, то и у разработчика хорошо бы запускать его в Linux-контейнере с локальным PostgreSQL, а не на Windows с MSSQL LocalDB, например. Конечно, не всё можно повторить локально, но стремиться к этому нужно. Если прод работает на Kubernetes, можно для разрабов настроить мини-кубер или хотя бы docker-compose с аналогичными сервисами.

**Проблемы, которые решает:** "Works on my machine" синдром, длительные циклы релизов, неожиданные баги, возникающие только в проде из-за отличий окружения, сложность внедрения новых разработчиков (если у них абсолютно иная среда, чем прод). Паритет окружений, по сути, про **сведение к минимуму сюрпризов** при переходе из dev в prod.

**Примеры хорошей практики:**

- Разработчик запускает приложение в **Docker** контейнере локально. Он использует тот же Dockerfile, что и на CI для продакшена. Благодаря этому, в локале у него та же версия ОС, тот же .NET Runtime, что и в проде. Разработчик тестирует фичу – если она работает в контейнере локально, велика вероятность, что и в продакшене (в таком же контейнере) она тоже будет работать. Паритет инструментов: Docker vs Docker, Linux vs Linux.

- Для **внешних сервисов**: если продакшен использует, скажем, Redis Cluster, разработчик не должен переключаться на иной тип хранилища (например, использовать InMemoryCache "пока локально"). Лучше поднять локально однонодовый Redis (например, через Docker) и пользоваться им. Да, возможно локально он менее производителен, нет кластеризации – но протокол и функциональность те же. Это значит, код, работающий с Redis, испытает те же команды, что и в проде. Часто в dev используют упрощенные варианты (Azure Storage Emulator вместо Azure Storage, SQLite файл вместо PostgreSQL) – это оправдано, если трудно развернуть настоящий сервис. Но нужно понимать, что каждый такой заменённый компонент – потенциальный рассадник несовместимостей. Если есть возможность, лучше использовать тот же тип сервиса. Сейчас облачные провайдеры позволяют разворачивать уменьшенные версии ресурсов даже для тестов, либо есть open-source аналоги (LocalStack для AWS, Azurite для Azure). 12-factor призывает: **минимум отличий**.

- **Infrastructure as Code:** Имитация окружения продакшена в контролируемой среде. Например, Docker Compose файл, который запускает: сервис приложения, сервис БД, сервис кэша – всё как в проде (может, меньших размеров). Разработчик или тестовый контур может поднять этим compose все компоненты и проверить интеграцию. Это обеспечивает паритет инструментов и конфигурации.

**Антипаттерны:**  
- **Разные настройки сборки:** Если dev-сборка компилируется с флагом "Debug with local stub", а prod-сборка – "Release with real integration", вы фактически имеете два разнородных приложения. Любая подобная условность – потенциальный источник ошибок. Конечно, бывают feature toggles для отключения интеграций, но старайтесь даже toggles тестировать включенными в похожих условиях.  
- **Ручное конфигурирование сред:** Если настройка dev-машины – это квест с установкой множества инструментов, отличный от продакшена, то новые разработчики тратят много времени на настройку. Лучше предоставить скрипты (или тот же Docker Compose) чтобы запустить "мини-прод". Если команда разработчиков на Windows, а прод на Linux – используйте WSL2 или containers, чтобы не было неожиданностей (например, чувствительность к регистру в путях, различия в разделителях – все эти штуки всплывают потом неожиданно).  
- **Длинные релизы:** Если вы разрабатываете фичу 3 месяца, потом интегрируете, потом тестируете и лишь через полгода выкатываете – за это время продакшен окружение может сильно измениться (новые версии зависимостей, другой масштаб). Чем чаще вы синхронизируете, тем лучше паритет. То есть, банально – внедряйте **Continuous Deployment**, а не выпускаете релизы раз в год.

**Практики:** Настройте **стейджинг среду**, максимально зеркальную продакшену, куда можно деплоить кандидатов и где разработчики могут тестировать в условиях близких к боевым. Стейджинг должен использовать те же типы ресурсов (если прод – SQL Server, то staging тоже SQL Server, а не SQLite). 

Инвестируйте во **документацию dev-окружения**: описывайте, как повторить окружение продакшена локально или в тестинге. Старайтесь автоматизировать: скрипты provisioning, контейнеризация, снапшоты баз для тестов. 

Применяйте одинаковые процессы: если в проде все через CI – делайте и локально через CI as code, хотя бы частично (например, `docker-compose.test.yml` который разворачивает всё и прогоняет интеграционные тесты – вы можете пускать его и локально и в CI).

Также, обучайте команду принципу: **"Не собираемся использовать в проде – не используем и в dev"**. Например, если решили отказаться от определённой библиотеки на проде, не разрабатывайте с ней локально "в целях удобства". Это иногда требует дисциплины (да, удобнее SQLite файл для небольшой БД, но если прод = PostgreSQL, лучше сразу его).

## XI. Логи (Logs)

**Определение:** **Лог приложения рассматривается как поток событий** ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%9B%D0%BE%D0%B3%D0%B8%20%D0%B2%20stdout)). Приложение должно писать свои логи *в стандартный вывод (stdout)*, не заботясь о их сохранении. Управление логами (сбор, хранение, анализ) берёт на себя окружение выполнения – например, хост-платформа или инструменты агрегирования логов. 

**Что это означает на практике:** Вместо записи логов в файл на диск (или в базу), приложение просто **печатает** их. В контейнерной среде вывод консоли каждого контейнера собирается Docker’ом и может перенаправляться в систему логирования (Elastic Stack, Splunk, Azure Monitor и т.п.). Это соответствует Unix-философии: "пиши в stdout, и пусть окружение решает, куда дальше отправить эти данные". Таким образом, приложение не волнуется о размере лог-файлов, ротации, доступности – оно просто выдаёт поток структурированных или строковых сообщений, а дальше их можно разделять по дням, индексировать, хранить сколько нужно вне самого приложения.

**Преимущества:** 
- **Простота:** Меньше кода и конфигов в самом приложении для логирования – не нужен код для открытия файлов, переключения файлов по дате, очистки. 
- **Единообразие:** Если все сервисы пишут в stdout, их логи можно собрать и смешать по таймстампам, видеть общую картину событий в системе, а не заходить на каждый сервер по отдельности.
- **Гибкость хранения:** Администратор окружения может настроить хранение логов по своим правилам (сколько дней, в какой системе). Приложению всё равно, оно не меняется, если мы решили вместо локальных файлов хранить логи в облачном сервисе – мы просто подключаем другой aggregator, а код не трогаем.
- **Dev удобство:** В разработке разработчик сразу видит логи в консоли при запуске `dotnet run`. Нет нужды открывать файлы или искать их – они перед глазами, что ускоряет отладку ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%AD%D1%82%D0%BE%20%D0%BF%D0%BE%D0%B7%D0%B2%D0%BE%D0%BB%D1%8F%D0%B5%D1%82%20%D0%B0%D0%B3%D1%80%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C%20%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F%20%D0%BE%D1%82,%D1%82%D0%B0%D0%BA%20%D0%B8%20%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%20%D0%BF%D1%80%D0%B5%D0%B4%D1%8B%D0%B4%D1%83%D1%89%D0%B5%D0%B9%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B)).

**Применение в .NET:** 
- По умолчанию, шаблоны ASP.NET Core настроены через Logging API выводить информацию в консоль. В режиме Development вы видите цветной лог в терминале (через `ConsoleLogger`). В Production, если запустить в консоли, будет похожий вывод, только без цвета. 
- Если использовать популярные лог-фреймворки (Serilog, NLog, etc.), то по 12-factor принципу их надо настроить на **Console sink**. Например, Serilog: `WriteTo.Console()` – и он будет писать в stdout. Можно дополнительно настроить форматы (JSON, текст), но выход – консоль.
- **Никаких `StreamWriter` в файл!** – если нужен файл в отладочных целях, лучше пусть это будет на уровне Docker (на самом деле Docker уже пишет stdout каждого контейнера в свой json-файл на хосте). Если очень нужен файл (например, легаси компонент), можно монтировать volume, но всё же предпочтительнее избегать. 
- В Windows-приложениях (не контейнер, а сервис) тоже лучше писать на консоль – там консоль может быть перенаправлена в системный лог. Если это Windows Service, который не имеет stdout, то логирование идёт в Event Log – что тоже вариант внешнего управления логами.

**Структурированные логи:** Хотя 12-factor не диктует формат, современные системы предпочитают **структурированные** (JSON) логи, чтобы потом удобно парсить. Многие .NET логгеры умеют выводить JSON в консоль. Это отлично дружит с 12-factor: приложение пишет JSON строки в stdout, агрегатор (например, fluentd) собирает и отправляет в Elastic – получаем удобную фильтрацию по полям.

**Антипаттерны:**  
- **Управление логами в приложении:** Если приложение само пытается архивировать старые логи, удалять их – это лишнее. В Kubernetes среде контейнер может жить недолго, и все логи должны уже быть экспортированы куда надо. 
- **Чрезмерный логгинг/секреты:** Нужно помнить, что всё, что пишется в лог, возможно, уйдёт в центральное хранилище. Поэтому не логируйте чувствительные данные (пароли, персональные данные) в нешифрованном виде. Это правило безопасности, не прямо 12-factor, но смежное. И если логируете слишком много (например, каждый запрос payload), убедитесь, что система хранения справится. Иначе нужно фильтровать.
- **Отсутствие логирования:** Тоже плохо – приложение, которое молчит, затрудняет сопровождение. 12-factor подразумевает, что у нас есть поток событий, и по нему можно судить о работе. Вы должны логировать хотя бы важные события (старт, стоп, ошибки, ключевые действия). В .NET есть ILogger – используйте его по назначению.

**Практики:** В Docker Compose можно использовать `docker logs -f <container>` во время отладки – увидите поток логов. В Kubernetes `kubectl logs -f pod/...`. То есть, сама платформа предоставляет доступ к stdout. Подключите инструмент мониторинга логов: ELK-stack (ElasticSearch + Kibana), или Azure Application Insights (он может собирать stdout ASP.NET Core автоматически), или даже simpler – `docker logs > file.txt`. 

Организуйте логи с уровнем детализации: Info, Debug, Error и т.д. В продакшене обычно включают Info и выше, Debug отключают, но при отладке можно включить. .NET конфигурируется через `Logging:LogLevel:Default` в appsettings или через env. Кстати, переменные окружения можно тоже использовать: напр., `Logging__LogLevel__Microsoft=Warning` – опять же, видим synergy с фактором III.

Если нужно коррелировать логи разных сервисов: включайте correlation ID в каждый лог (например, traceidentifier для запросов). Это не относится строго к 12-factor, но помогает анализировать единый поток событий из разных источников ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%83%20%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%20%D0%B8%D0%BB%D0%B8%20%D0%B0%D1%80%D1%85%D0%B8%D0%B2%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)). 12-factor отмечает, что агрегированная система логов способна объединить события от **всех процессов и сервисов** ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D1%84%D0%B0%D0%B9%D0%BB%D0%B0%D0%BC%D0%B8%20%28%D0%B0%D1%80%D1%85%D0%B8%D0%B2%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C%20%D0%B8%D0%BB%D0%B8%20%D1%83%D0%B4%D0%B0%D0%BB%D1%8F%D1%82%D1%8C%29,%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%83%20%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%20%D0%B8%D0%BB%D0%B8%20%D0%B0%D1%80%D1%85%D0%B8%D0%B2%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)), а значит, вы сможете отфильтровать, например, все события по заказу #1234 через все сервисы.

## XII. Административные процессы (Admin processes)

**Определение:** Одноразовые или административные задачи (выполняемые не постоянно, а время от времени) следует запускать как **отдельные процессы**, используя тот же код и конфигурацию, что и основное приложение ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=%D0%A0%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5%20%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B%20%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%20,%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0%D0%BC%2C%20%D1%87%D1%82%D0%BE%20%D0%B8%20%D0%BE%D1%81%D1%82%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%20%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B)). Такие задачи не являются частью обычного потока обработки запросов, но могут потребоваться для обслуживания приложения: например, миграция базы данных, запуск скрипта перерасчёта данных, разовая отправка уведомлений, очистка кешей и т.п.

**Основная идея:** *Административный процесс* должен быть **равноправен** обычному процессу приложения:
- Он берёт код из того же репозитория (никаких отдельных утилит вне основной кодовой базы).
- Он использует те же зависимости (не нужно отдельное окружение или особые библиотеки – всё прописано в общих dependency манифестах).
- Он настраивается через те же переменные окружения (например, скрипт миграции будет читать строку подключения базы из тех же переменных, что и само приложение) ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=,%D0%B1%D1%8B%D0%BB%D0%BE%20%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D1%8C%20%D0%B2%20%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D1%85%20%D0%BE%D0%BA%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%D1%85)).

Такие процессы должны выполняться в **том же окружении**, что и приложение, просто запускаются по требованию и завершаются по окончании задачи.

**Пример (EF Core миграции):** Очень распространённый сценарий – миграция схемы БД при деплое новой версии. В .NET есть механизм **EF Core Migrations**: обычно разработчики создают миграции (код, описывающий изменения схемы) и перед развёртыванием новой версии их нужно прогнать против базы. По 12-factor, мы *не интегрируем* миграции в постоянно работающий веб-процесс (чтобы, например, при старте веб-приложение само применяло миграции – это может быть опасно при множестве экземпляров). Вместо этого, делается так: после релиза, перед запуском новых веб-процессов, выполняется *админ-процесс* миграции. Например, можно запустить контейнер с образом приложения, но с командой `dotnet MyApp.dll --apply-migrations` (предположим, мы заложили такой режим). Этот процесс единоразово стартует, читает ту же `ConnectionStrings__Default` переменную, подключается к базе, выполняет миграции и завершается. После этого основное приложение (веб-процессы) запускается уже на обновлённой схеме. Такой подход гарантирует, что миграция выполнена тем же кодом (нашем .dll с EFCore), в той же версии, что и основное приложение, и с теми же настройками доступа. Нет риска, что миграцию применит “левый” скрипт, не учтённый в репо, или не та версия.

**Другие примеры:**
- Скрипт наполнения базы начальными данными (seeding). Запускается аналогично миграции, либо как часть миграции.
- Одноразовый анализ или исправление данных. Например, баг в проде повредил данные, и нужно разово поправить. Пишется разовый скрипт (в том же репо, возможно в папке Tools или прямо как консольная команда), деплоится вместе с кодом и запускается как отдельный job.
- Администрирование через REPL. В 12-factor оригинале упоминается возможность запускать консоль/REPL приложения для отладки. В .NET это менее принято, но можно представить, например, запуска `dotnet MyApp.dll --shell` который открывает интерактив, позволяющий выполнять команды с тем же контекстом, что у приложения. Это больше экзотика, чаще – конкретные скрипты.

**Подводные камни:**  
- **Не запускать в обход релиза:** Иногда админы запускают «какой-то .exe» на продакшене для починки. Плохо, если этот exe не из того же релиза. Например, старый миграционный скрипт, оставшийся на сервере, могут по ошибке запустить на новую базу – итог непредсказуем. Дисциплина 12-factor подразумевает: если нужно выполнить ад-хок задачу – включи её в кодовую базу (может, отдельным коммитом, который потом можно откатить), выкатите как часть релиза и запустите. Тогда всё под контролем версий.  
- **Чистка после себя:** Разовый процесс должен корректно завершаться (см. фактор IX). Если он не успел за отведенное время – встанет вопрос, что делать. Планировщик (если вы используете K8s CronJob, Azure WebJob Triggered) может оборвать или повторить. Код скрипта должен быть написан так, чтобы можно было безопасно запустить заново или продолжить вручную, если он был прерван.
- **Разграничение прав:** Админ-процесс зачастую имеет повышенные права (например, миграция – право изменять схему). Убедитесь, что на время выполнения у него есть нужные права, но не оставляйте приложение с этими правами постоянно. В реальности, правда, приложения часто имеют права на DDL, но по идее, можно выдавать временно. Здесь разумно соблюдать баланс безопасности и удобства.

**Практики:** Включите выполнение миграций в ваш **pipeline деплоя**. Многие поступают так: откатили трафик, остановили приложение, выполнили миграции, запустили новую версию. Либо в zero-downtime scenario: сначала миграции (они сделают новую схему, совместимую и со старой, и с новой версией), потом плавный перевыпуск приложений. Как бы ни было – миграции управляются как код (EF .cs файлы) и запускаются идентичным окружению способом (через `dotnet ef database update` или вызовом внутри приложения).

Документируйте часто используемые админ-команды. Например: *"Для обновления конфигурации кеша запустите `dotnet MyApp.dll --reset-cache`”*. Это поможет команде знать, что делать при особых операциях. Хорошо, если эти команды можно запускать не только в проде, но и локально (для теста). Например, `--apply-migrations` можно протестировать на локальной SQLite/SQLExpress перед тем, как доверять продакшену.

Используйте средства платформы: в Kubernetes – **Job/CronJob** для одноразовых задач. В Azure App Services – **WebJobs** или отдельные Functions. Главное – тот же код. Один из подходов: заверните вашу задачу в отдельный проект, но деплойте его в виде того же контейнера, просто с разной командой. Либо, если приложение монолитное, иметь entrypoint, который смотрит переменную например `RUN_MIGRATIONS=true` – и тогда вместо обычного запуска выполняет миграции и выходит.

---

Теперь, когда мы рассмотрели все 12 факторов в деталях, давайте проследим, как они проявляются в полном жизненном цикле приложения и попробуем применить знания на практике.

## Полный цикл разработки и деплоя 12-факторного приложения

Чтобы связать все вышеперечисленные принципы воедино, рассмотрим сценарий полного цикла: от разработки новой фичи до мониторинга запущенного приложения в продакшене, на примере 12-факторного подхода.

1. **Разработка фичи:** Разработчик берёт актуальный код из одного источника – git-репозитория (Фактор I: кодовая база едина). Перед началом он обновляет зависимости (`dotnet restore`), убедившись, что среда настроена (возможно, запустив Docker Compose для БД/кеша – факторы II и X, явные зависимости и паритет среды). Он пишет код, не вшивая никаких конфигов – например, для новой интеграции с API добавляет в `appsettings.json` ключ с пустым URL, и будет ожидать его через переменную среды (Фактор III). Локально разработчик заводит файл `.env` с нужными тестовыми параметрами, либо настройка уже прописана в его user-secrets (в ASP.NET Core) – так или иначе, код не содержит секретов.

2. **Тестирование локально:** Разработчик запускает приложение (например, `docker compose up` или `dotnet run` с нужными env). Приложение поднимается за секунды (Фактор IX: быстрота стартов), и автоматически подключается к локальным сервисам (БД, очередь) через переменные окружения. Разработчик генерирует тестовые ситуации: делает запросы, которые задействуют новые зависимости. Если чего-то не хватает (например, Redis не запущен), приложение выдаст ошибку о подключении – это быстрый сигнал, и разработчик поднимает недостающий сервис (Фактор II: все нужные зависимости должны быть заявлены, тут же становится ясно, если какая-то не настроена). Исправив, он видит логи прямо в консоли (Фактор XI: логирование в stdout) и может быстро отследить, что происходит.

3. **Commit и CI/CD:** После локальных проверок разработчик коммитит изменения и открывает Pull Request. Автоматизированный **CI** запускается: он на чистом изолированном агенте выполняет сборку (Fактор V: build stage) – `dotnet publish` собрал приложение, затем `docker build` запаковал образ. При сборке подтянулись все NuGet, Node-модули и т.д. (Фактор II, явные зависим.). CI также прогоняет тесты. В конфигурации CI явно указаны переменные для тестовой БД, возможно, CI запускает контейнер с тестовой БД (Фактор IV: backing service – используй подключаемый ресурс для БД). Все тесты прошли – артефакт (образ Docker) считается **сборкой** готовой.

4. **Release:** CD-пайплайн берёт собранный образ (идентифицированный, например, sha образа `abc123`) и готовит релиз на стейджинг-среду. В Kubernetes создаётся новый Deployment с образом `abc123` и набором ConfigMap/Secrets с переменными окружения для staging (Фактор III). Это считается новым **релизом** (имеет версию или номер). Оркестратор разворачивает релиз: 
   - Если нужны миграции, сначала запускается `kubectl job migrate-abc123` – джоб на основе того же образа, но с командой `dotnet MyApp.dll --apply-migrations` (Фактор XII: админ процесс, миграция). Он подтягивает Secrets (строка подключения) и выполняет миграцию, завершается успешно.
   - Затем запускаются сами **Run-процессы**:, скажем, 3 реплики веб-приложения и 2 реплики воркера. Они стартуют, каждый *в отдельном контейнере/процессе* (Фактор VI: процессы, и Фактор VIII: параллелизм – несколько экземпляров). Стартуют быстро, регистрируются как готовые через readinessProbe (Фактор IX). K8s балансирует трафик между ними.
   - Логи каждого контейнера собираются с stdout с помощью установленного log-агента (например, Fluent Bit) и отправляются в центральное хранилище. Разработчик или QA может через Kibana посмотреть, что происходит (Фактор XI).

5. **Проверка на стейджинге:** Команда QA проверяет новую фичу в максимально продоподобной среде (Фактор X: паритет – staging = prod по конфигу и окружению, отличия минимум). Всё выглядит хорошо. 

6. **Деплой в продакшен:** CD продолжает, либо вручную одобряют – новая версия `abc123` раскатывается на прод. Здесь аналогично: миграции (если есть) – отдельным процессом, потом обновление Deployment. Чтобы исключить простой, используют rolling update: новые поды поднимаются параллельно со старыми, при этом приложение спроектировано так, что новая версия совместима (backwards) на время деплоя. Например, factor X – dev/prod parity – мы уже миграции сделали так, чтобы они не ломали старую версию, значит некоторое время старая и новая живут вместе. После обновления все старые поды остановлены. Они при остановке получили SIGTERM, **корректно закрылись**, дописав последние логи и отпустив сессии (Фактор IX). 

   Новые экземпляры обрабатывают весь трафик. Они работают с облачными базами, очередями – все ресурсы как обычно через переменные. 

7. **Масштабирование под нагрузку:** Допустим, внезапно вырос трафик. Kubernetes Horizontal Pod Autoscaler или оператор вручную решает увеличить количество экземпляров веб-процесса с 3 до 6. Просто запускаются 3 новых контейнера того же релиза. Благодаря тому, что **приложение стателесс** (Фактор VI) и быстро стартует (IX), в течение полуминуты мы удвоили пропускную способность – новые процессы встали в строй. Если бы в приложении был stateful singletons, были бы проблемы – но у нас всё состояние в Redis/SQL, поэтому 6 процессов работают так же, как 3. Для фоновых воркеров, скажем, 2 хватало – их не трогаем (разные типы процессов масштабируются независимо, Фактор VIII).

8. **Мониторинг и логирование:** Во время работы продакшена команда следит за **метриками** и **логами**. Метрики (CPU, память, количество запросов) собирает, например, Prometheus – приложение даже может выставлять `/metrics` endpoint. Логи смотрят через централизованную систему. Например, произошла ошибка – разработчик видит stacktrace через Kibana, либо Application Insights прислал алерт с ошибкой (AI тоже ловит исключения через подключенный логлистенер). Из лога видно, какой релиз (версия) и какая переменная окружения (можно логировать EnvironmentName) – всё прозрачно. Если баг критичный, разработчик оперативно делает фикс, катит новую версию – благодаря непрерывному процессу, hotfix может быть на проде через час после обнаружения.

9. **Администрирование:** В процессе эксплуатации может потребоваться выполнить админ-задачу. Например, нужно разово удалить дубли в базе. Разработчики пишут небольшой консольный скрипт на C# в проекте *Tools* внутри репо, который подключается к БД и чистит дубли. Они используют тот же *DbContext* и модели из основного проекта – reuse кода. Компилируют, внедряют в образ. Затем на продакшене запускают Kubernetes Job с командой `dotnet Tools.dll --clean-dupes`. Он стартует контейнер, подключается через ту же конфиг, делает своё дело и успешно завершается. В логах мы видим его вывод, при завершении он самоуничтожается. База очищена, основной сервис не прерывался (или был в maintenance режим, зависит от задачи).

10. **Окончание жизненного цикла:** Со временем приложение развивается, старые версии релизов хранятся (может, Docker Registry держит образы). Если нужно откатиться – можно переDEPLOYить старый образ с соответствующей конфигурацией, так как всё в VCS. Когда приложение устареет и будет выведено, контейнеры просто остановят (они и так ничего сами не хранят). Данные остаются во внешних хранилищах, которые либо мигрируют, либо тоже отключат. 

В этом сценарии мы проследили, как **каждый из 12 факторов** облегчает определённый этап: от разработки (конфиг, зависимости, паритет), до деплоя (сборка/релиз/запуск), до масштабирования (процессы, параллелизм, stateless), до операционного управления (логи, админ-процессы, быстрые рестарты). Методология 12-Factor создаёт своего рода *контракт* для приложения: если оно этому следует, то эксплуатация и развитие приложения упрощаются, его легче перемещать в облако, разделять на микросервисы, поддерживать CI/CD и т.д.

Методология Twelve-Factor App стала фундаментом для **cloud-native** приложений. Соблюдение этих 12 принципов не гарантирует идеального кода, но создаёт прочную основу для **масштабируемости, портативности и удобства сопровождения**. В мире микросервисов, контейнеров и Kubernetes данные практики практически стали стандартом де-факто.

Важно понимать, что 12 факторов – это не жёсткий стандарт или рецепт, а именно принципы. Бывают ситуации, где отступления возможны, но знать их последствия – задача грамотного инженера. Например, хранение конфигурации частично в файлах может быть допустимо, если есть механизм внешнего управления этими файлами. Или логирование в файловую систему может иметь место в десктоп-приложении, которое не является SaaS. Однако для веб-сервисов, стремящихся к высокой доступности и быстрому развитию, 12-Factor подход чрезвычайно полезен.

**Краткие выводы по каждому фактору:**

- *Кодовая база:* единый источник правды, никаких "дрейфующих" копий кода.
- *Зависимости:* полная декларация и изоляция – облегчает onboarding и деплой.
- *Конфигурация:* отделение кода и настроек – гибкость и безопасность.
- *Backing services:* взаимозаменяемость внешних сервисов – портативность и отказоустойчивость.
- *Build/Release/Run:* четкий конвейер до запуска – надежные повторяемые релизы, возможность быстрого отката.
- *Процессы:* статeless, share-nothing – масштабирование и устойчивость к падениям.
- *Port binding:* самодостаточное приложение – можно развернуть в любом окружении с минимальными зависимостями.
- *Concurrency:* модель масштабирования через процессы – позволяет эффективно использовать ресурсы и разделять обязанности.
- *Disposability:* быстро стартуем, корректно останавливаемся – минимизируем downtime и упрощаем операционную работу (релизы, масштабирование, recover).
- *Dev/Prod parity:* среда разработки приближена к боевой – меньше сюрпризов, быстрее цикл доставки.
- *Logs:* централизуем логи, приложение не думает о них – наблюдаемость системы повышается, локально проще отлаживать.
- *Admin processes:* такие же граждане, как и приложение – поддерживаем одинаковый подход к коду и конфигу, избегаем "дрейфа" версий скриптов.

В работе над реальными проектами рекомендуется время от времени сверяться с этими факторами, особенно когда приложение растёт и усложняется. Многие современные **инструменты и фреймворки уже содержат поддержка 12-factor практик**: например, ASP.NET Core (configuration providers, builtin Kestrel, DI), Docker и Kubernetes (для изоляции зависимостей, конфигов, процессов), облачные сервисы (настройка env vars, логирование). Наша задача как разработчиков – правильно их использовать.

В конце концов, следование Twelve-Factor методологии помогает наладить эффективное взаимодействие разработки и эксплуатации (DevOps) и ускоряет выпуск новых функций. Это особенно ценно для стартапов и продуктов, которые быстро evolv’ятся, но и в enterprise-разработке принципы 12 факторов улучшили практики развёртывания и поддержки приложений.

## Ресурсы для самостоятельного изучения

- **Официальный сайт методологии Twelve-Factor App:** перевод на русский ([Концепция Twelve-Factor App и Kubernetes / Хабр](https://habr.com/ru/companies/slurm/articles/785658/#:~:text=%D0%95%D1%81%D0%BB%D0%B8%20%D0%BA%D1%80%D0%B0%D1%82%D0%BA%D0%BE%2C%20%D1%82%D0%BE%20%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BD%D0%BE%20%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D0%B0%D0%BC,SaaS%29%20%D0%B4%D0%BE%D0%BB%D0%B6%D0%BD%D0%BE)) ([12-факторное приложение - The Twelve-Factor App](https://devopsgu.ru/blog/posts/the-twelve-factor-app/#:~:text=VIII)) – содержит оригинальные формулировки принципов и примеры на разных языках.  
- **Документация Microsoft: Конфигурация и настройка ASP.NET Core:** объясняет, как работать с переменными окружения, Secret Manager и др., что коррелирует с фактором III (см. Microsoft Learn: *Configuration in .NET*) ([Работа с конфигурацией в ASP.NET Core - Tproger](https://tproger.ru/articles/rabota-s-konfiguraciej-v-asp-net-core--prakticheskoe-rukovodstvo-s-nastrojkami-mongodb-251910#:~:text=%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D1%81%20%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%B5%D0%B9%20%D0%B2%20ASP,json%29%2C%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%BE%D0%BA%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%B8%20%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%B5)).  
- **Статья на Habr:** «Простыми словами о Twelve-Factor App» ([Простыми словами о Twelve-Factor App / Хабр](https://habr.com/ru/articles/261171/#:~:text=%D0%98%D0%B7%D0%B2%D0%B5%D1%81%D1%82%D0%BD%D1%8B%D0%B9%20%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B9%D0%B4%D0%B5%D1%80%20heroku%20%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%B8%D0%B2%D0%B0%D0%B5%D1%82%20%D0%BC%D0%B0%D0%BD%D0%B8%D1%84%D0%B5%D1%81%D1%82%2C,%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8%20%D0%BE%D0%BF%D0%B8%D1%81%D1%8B%D0%B2%D0%B0%D1%8E%D1%82%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%2C%20%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5%20%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D1%8B)) – более краткое и неформальное объяснение принципов, полезно для повторения.  
- **Книга «.NET Microservices: Architecture for Containerized .NET Applications» (Microsoft Press):** хотя не напрямую о 12-факторном приложении, содержит главы о конфигурации, логировании, обработке ошибок – по сути, best practices для .NET, которые перекликаются с нашими принципами.  
- **Видео-доклад:** *“The 12 Factor App – .NET Core examples”* – докладчик Alexander Yashin, есть на YouTube ([«The 12 factor app» – Александр Яшин | Митап SoftTeco - YouTube](https://www.youtube.com/watch?v=D7cO6RnvpZE#:~:text=YouTube%20www,NET%20Core)). Показывает применение 12 факторов на практике в .NET Core проектах.  
- **Habr Article:** «Концепция Twelve-Factor App и Kubernetes» ([Концепция Twelve-Factor App и Kubernetes / Хабр](https://habr.com/ru/companies/slurm/articles/785658/#:~:text=%D0%90%D0%B2%D1%82%D0%BE%D1%80%20%D0%BE%D1%80%D0%B8%D0%B3%D0%B8%D0%BD%D0%B0%D0%BB%D0%B0%3A%20Kintul%20Upadhyay)) ([Концепция Twelve-Factor App и Kubernetes / Хабр](https://habr.com/ru/companies/slurm/articles/785658/#:~:text=%D0%9A%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%86%D0%B8%D1%8F%20Twelve,%D0%BE%D0%B4%D0%BD%D0%BE%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%BC%D0%B8%20%D0%B8%20%D0%BB%D1%91%D0%B3%D0%BA%D0%B8%D0%BC%D0%B8%20%D0%B2%20%D0%BC%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8)) – рассматривает актуальность 12-факторного приложения в эпоху контейнеров, с примерами адаптации под Kubernetes (хорошо для понимания, как факторы воплощаются в helm-чартах, ConfigMap и т.д.).  
- **Tutorial:** Попробуйте самостоятельно контейнеризовать простое ASP.NET Core приложение, следуя guid’ам, например, на Microsoft Docs (*Deploying an ASP.NET container to Docker*). Практика с Docker закрепит факторы II, V, VII, X, XI в реальной работе.

Используя эти ресурсы и принципы, вы сможете проектировать приложения, готовые к облачным нагрузкам и эффективной непрерывной доставке. Пусть 12 факторов станут для вас своего рода чек-листом качества архитектуры вашего сервиса.

